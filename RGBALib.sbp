'RGBA_CRT's Librarys
#include <RGBADef.sbp>
/*  Todo : 
		HTTP系をクラスに
*/


'--------------------------------------------------------
'	要求APIが環境依存（Win95デフォルトから外れるもの）
'--------------------------------------------------------

' %fが使える
Declare Function printfvc cdecl Lib "msvcrt.dll" Alias "printf" (str as BytePtr,format as BytePtr, ...) As Long
Declare Function printfd cdecl Lib "msvcrt.dll" Alias "printf" (format as BytePtr, v1 AS Double,...) As Long


'---------------
'	Macros
'---------------
Const Abs16bit(b) = (b xor (b >> 15)) - (b >> 15) As Word
Const ChangeEndianWord(x) = ((x>>8) and &HFF) or (x and &HFF)<<8

'----------------------------
'		GUI Utility
'----------------------------
Sub PumpMessage() 
	Dim msg As MSG
 	while PeekMessage( msg, NULL, 0, 0, PM_REMOVE ) 
    TranslateMessage( msg )
    DispatchMessage( msg )
  	Wend
EndSub

Function GetDlgItemHex(hWnd AS HWND) AS Long
	Dim buf as BytePtr,Length AS Long
	Length=GetWindowTextLength(hWnd)
	buf=calloc(Length+5)
	GetWindowText(hWnd,buf,Length+1)
	Dim i as Long,mode as Long
	Do
		if buf[i]=&H20 Then 
			i++
			Continue'Skip Space
		Elseif buf[i]=&H30 Then	'0'
			if buf[i+1]=&H78 Or buf[i+1]=&H58 Then	'x'
				'16進決定,0xを&Hに変更
				buf[i]=&H26:	buf[i+1]=&H48
			endif
		endif
		ExitDo		
	Loop
	GetDlgItemHex=Val(buf+i) AS Long
	free(buf)
EndFunction

Function GetDlgItemDouble(hWnd AS HWND) AS Double
	Dim buf as BytePtr,Length AS Long
	Length=GetWindowTextLength(hWnd)
	buf=calloc(Length+5)
	GetWindowText(hWnd,buf,Length+1)
	GetDlgItemDouble=Val(buf)' AS Long
	free(buf)
EndFunction

'Auto Allocate
Function GetWndTextAA(hWnd AS HWND) AS BytePtr
	Dim buf as BytePtr,Length AS Long
	Length=GetWindowTextLength(hWnd)
	GetWndTextAA=calloc(Length+5)
	GetWindowText(hWnd,GetWndTextAA,Length+1)
EndFunction

'エラーメッセージ表示
Function ErrMes(hOwner AS HWND,Text As BytePtr,Title As BytePtr,Flag As Dword) As Long
	SetForegroundWindow(hOwner)
	MessageBeep(MB_ICONHAND)
	ErrMes=MessageBox(hOwner,Text,ProgramName+" - "+MakeStr(Title),MB_ICONERROR Or Flag)
EndFunction

'printfのMessageBox版
Function MessageBoxf(hWnd AS HWND,lpCaption AS BytePtr,uType AS DWord,lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord ) AS Long
	Dim buf[1024] As Byte	'wsprintfがそもそも1024バイトしか対応してない
	wsprintf(buf,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	MessageBoxf=MessageBox(hWnd,buf,lpCaption,uType)
EndFunction

'EXEC 終了コード取得
Function RunAndGetExitCode(App As BytePtr,CmdLine As BytePtr) AS Long
	Dim si AS STARTUPINFO 
	Dim pi As PROCESS_INFORMATION
	Dim Child As HANDLE
	Dim r As DWORD

	if CreateProcess(App,CmdLine,ByVal NULL,ByVal NULL,FALSE,CREATE_NEW_CONSOLE,NULL,NULL,si,pi)=FALSE Then'CREATE_NEW_CONSOLE を 0にすれば非表示
		RunAndGetExitCode=-1
		ExitFunction
	endif

	' 子プロセス起動成功
	Child = pi.hProcess

	' 不要なスレッドハンドルをクローズする
	CloseHandle(pi.hThread)

	' 子プロセスの終了待ち
	r = WaitForSingleObject(Child, INFINITE)
	if r<>WAIT_OBJECT_0 then
		'wait error!
		RunAndGetExitCode=-1
		ExitFunction
	endif

	' 子プロセスの終了コードを取得
	Dim exitCode As DWORD
	if GetExitCodeProcess(Child, exitCode)=FALSE then
		RunAndGetExitCode=-1
		ExitFunction
	endif

	if Child<>0 then CloseHandle(Child)
	RunAndGetExitCode=exitCode
Endfunction

'----------------------
'		Binaly
'----------------------
Sub ChangeEndianDW(ByRef in As DWord)
	Dim Tmp As Byte
	Dim value As *Byte
	value=VarPtr(in)
	Tmp=value[0]
	value[0]=value[3]
	value[3]=Tmp
	Tmp=value[1]
	value[1]=value[2]
	value[2]=Tmp
EndSub

Function Str2Dw(Data As BytePtr) As DWORD
	memcpy(VarPtr(Str2Dw),Data,4)
endfunction

Function Dw2Str(Data As DWORD) As String
	Dim Str[4] As Byte
	memcpy(Str,VarPtr(Data),4)
	Str[4]=0
	Dw2Str=MakeStr(Str)
EndFunction

'InStrのバイナリ版
Function InByteBin(Data As BytePtr,Size As DWORD,Bytes As Byte)(Jump AS Long) As Long
	Dim i As DWORD,tmp As Byte
	if Jump<>0 then i=Jump
	Do
		if Data[i]=Bytes Then InByteBin=i: ExitDo
		i++
		if i => Size then InByteBin=-1: ExitDo
	Loop
EndFunction

'---------------
'	Strings
'--------------


Function UTF16ToSJIS(utf16 AS BytePtr) AS BytePtr
	Dim l AS DWord
   ' UnicodeからShift-JISに変換
   l=WideCharToMultiByte(CP_ACP, 0, utf16, -1, 0, 0, 0, 0)
   UTF16ToSJIS=calloc(l)
   WideCharToMultiByte(CP_ACP, 0, utf16, -1, UTF16ToSJIS, l, 0, 0)
End Function



'BM法文字列サーチ（指定文字列内に特定の文字列があるか？＝True or false）(バグあり)
Function SerchTextLine(Src As BytePtr,Text As BytePtr,sLen As DWORD,isFirst As DWORD) As Byte
	Dim Skip[255] As DWORD
	Dim tLen As DWORD'(,sLen As DWORD
	Dim i As DWORD,j As Long,k As Long
	Dim letSkip As Byte, letLast As Byte
	Dim SP AS Long
	tLen=lstrlen(Text)
	if tLen=0 then 	SerchTextLine=FALSE:	ExitFunction
	For i=0 To 255 : Skip[i]=tLen :	Next i
	For i=0 To tLen-1 
		Skip[Text[i]]=tLen-1-i 
		if Skip[Text[i]]=0 then Skip[Text[i]]=1
	Next i
	tLen--
	letLast=Text[tLen]
	For i=tLen To sLen Step Skip[letSkip]
		letSkip=Src[i]
		if letSkip=letLast Then 
			j=i-1
			k=tLen-1
			While Src[j]=Text[k]
				if k=0 then 
					Goto *FOUND
				Endif
				j--
				k--
			Wend
		Endif
	Next i
	SerchTextLine=FALSE
	ExitFunction
*FOUND
	Dim Line As BytePtr
	Dim EP As Long
	SerchTextLine=TRUE
*RETRY
	if Src[j-SP]= &H0A Or Src[j-SP]=&H0D Then if isFirst<>0 then SP--: Goto *RETRY
	EP=InStrByte(Src+j,&H0D,sLen)'+j
	if EP=0 then EP=sLen
	if EP-SP<=1 then ExitFunction
EndFunction

'未デバッグ
Function FindStr(text AS BytePtr,size aS DWord,target AS BytePtr) aS Long
	Dim i AS Long,tarLen AS Long
	tarLen=lstrlen(target)
	Do
		if text[i]=target[0] Then
			if CompareString(LOCALE_SYSTEM_DEFAULT,0,text+i,tarLen,target,tarLen)=CSTR_EQUAL Then
				ExitDo
			Else
				i+=tarLen
			End If
		Else If text[i]=0 Then
			FindStr=-1
			ExitFunction
		End If
		i++
		if i>size Then ExitDo
	Loop
	FindStr=i
End Function

'この関数は作り直したほうがいい
Function InStrByte(Data As BytePtr,Serch As Byte,DataSize As DWORD) As Long
	Dim i as DWORD,si As Dword, sLen As Long
	Do
		if Data[i]=Serch then	InStrByte=i	: ExitDo
		if i=DataSize then
			InStrByte=-1
			ExitFunction
		endif
		i++
	Loop
endfunction

'APIを使った高速バージョンのダブルクォーテーション抜き
Function DelDQ(Text As BytePtr) As BytePtr
	Dim tmp[MAX_PATH] AS Byte
	lstrcpy(tmp,Text)
	PathRemoveBlanks(tmp)
	PathUnquoteSpaces(tmp)

	Dim txlen AS DWord
	txlen=lstrlen(tmp)
	DelDQ=calloc(txlen+2)
	memcpy(DelDQ,tmp,txlen+1)
EndFunction

'LF,CR -> CRLF     戻り値は別メモリなので各自開放すること
Function ConvCRLF(Text As *Byte) As BytePtr
	Dim ti As Long
	dim ci as long
	Dim l as Long
	Dim lp as Long
	Dim CRLFD As *Byte

	ti=0
	ci=0

	l= lstrlen(Text)
	CRLFD=calloc2(l+5)

	Do
		if Text[ti] = &H0A then				'0A(LF)が発見され、
			if Text[ti-1] <> &H0D then		'0D(CR)その後ろがCR以外の場合
				CRLFD[ci]=&H0D				'CRを追加
				ci++
				l++
				lp++
				CRLFD=realloc2(CRLFD,l+lp*2)	'増えた分のメモリ確保
				CRLFD[ci]=&H0A				'そしてLFを追加
			Else
				CRLFD[ci]=&H0A				'違ったら（正しくCRLFになってたら）そのまま
			Endif
		Elseif Text[ti] = &H0D then			'↑と大体同じ
			if Text[ti+1] <> &H0A then
				CRLFD[ci]=&H0D
				ci++
				l++
				lp++
				CRLFD=realloc2(CRLFD,l+lp*2)
				CRLFD[ci]=&H0A
			Else
				CRLFD[ci]=&H0D
			Endif
		Else
			CRLFD[ci]=Text[ti]				'改行文字と無関係の場合
		Endif 
		ti++
		ci++
		if ti = l Then ExitDo		
	Loop

	'メモリを確保し、戻り値をセット
	ConvCRLF=calloc2(lstrlen(CRLFD)<<1)
	lstrcpy(ConvCRLF,CRLFD)	

	'消す
	free2(CRLFD)
EndFunction

'strcmpの文字数指定バージョン
Function win_strncmpi(str1 AS BytePtr,str2 AS BytePtr,Length AS DWord) AS BOOL
	if CompareString(LOCALE_SYSTEM_DEFAULT,NORM_IGNORECASE,str1,Length,str2,Length) = CSTR_EQUAL Then
		win_strncmpi=TRUE
	Else
		win_strncmpi=FALSE
	endif
EndFunction

Function win_strncmp(str1 AS BytePtr,str2 AS BytePtr,Length AS DWord) AS BOOL
	if CompareString(LOCALE_SYSTEM_DEFAULT,0,str1,Length,str2,Length) = CSTR_EQUAL Then
		win_strncmp=TRUE
	Else
		win_strncmp=FALSE
	endif
EndFunction

'ファイルパスが正しいかチェック
Function IsFilePath(FilePath AS BytePtr) As Byte
	Dim hFile AS HANDLE,dFilePath As BytePtr
	if FilePath[0]=&H22 Then 
		dFilePath=DelDQ(FilePath)
	Else
		dFilePath=FilePath
	endif
	hFile=CreateFile(dFilePath,GENERIC_READ,FILE_SHARE_READ OR FILE_SHARE_WRITE,ByVal NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL)
	If hFile=INVALID_HANDLE_VALUE Then
		IsFilePath=FALSE
	Else
		IsFilePath=TRUE
		CloseHandle(hFile)
	EndIf
	if FilePath<>dFilePath Then free(dFilePath)
EndFunction

Function sprintfStr(lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord ) AS String
	Dim Buf[PRINTF_BUFFER] AS Byte,ret AS Long
	ret=wsprintf(Buf,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	sprintfStr=MakeStr(Buf)
EndFunction


'------------------------------
'		Network library
'------------------------------

'URLのパーセントエンコードを解除
Function URLDecode(pFrom As BytePtr) As BytePtr
   	Dim i = 0 As DWord
	Dim ASCII As Byte
	URLDecode=calloc(MAX_PATH+5)

   Do 
		if pFrom[i]=&H25 Then '% then
			ASCII=Hex2Dec(Chr$(pFrom[i+1])+Chr$(pFrom[i+2])) AS Byte
			lstrcat(URLDecode , Chr$(ASCII))
			i=i+2
		Else
			lstrcat(URLDecode , Chr$(pFrom[i]))
		Endif
		i++			
		if pFrom[i] = 0 Then ExitDo
   Loop
End Function

'軽量化のため、移動
'Function GetHttpStatusText(HttpStatusNo As Long)

'-------------------------------------
'  Dynamic DLL Loader + cdeclLoader
'-------------------------------------
Type DLL_FUNCTION_CELL
	'関数ポインタを格納するための変数へのポインタ
	ptr AS VoidPtr
	'DLLから探す関数名
	alias AS BytePtr
EndType

'TST_DecoderDllLoaderへ改名、Decodersフォルダ内にデコーダを格納するように変更。↓の関数はRGBALibに移動
Function DynamicDllLoader(DllName AS BytePtr,func_list AS *DLL_FUNCTION_CELL,count AS Long)(opt_text AS BytePtr,hWnd AS HWND) As HINSTANCE
	Dim hDll AS HINSTANCE
	Dim errMes AS BytePtr

	hDll=LoadLibrary(DllName)
	if hDll=0 Then
		errMes=calloc(1024)
		if opt_text=0 Then opt_text=""
		wsprintf(errMes,ex"%s%sのロードに失敗しました。\nDLLが存在するか確認してください。\nErrorCode : %d",DllName,opt_text,GetLastError())
		Goto *DDL_RETURN_ERROR
	endif

	Dim i AS Long
	For i = 0 To count-1
		if func_list[i].ptr=0 or func_list[i].alias=0 Then Goto *DDL_RETURN_ERROR
		SetDWord(func_list[i].ptr,GetProcAddress(hDll,func_list[i].alias))	'Func_List.ptrの先に関数ポインタを格納
		if GetDWord(func_list[i].ptr)=NULL Then
			errMes=calloc(1024)
			if opt_text=0 Then opt_text=""
			wsprintf(errMes,ex"%sから必要な関数が見つかりませんでした。\n正しいバージョンのDLLか確認してください。\nProcName : %s\nErrorCode : %d",DllName,func_list[i].alias,GetLastError())
			Goto *DDL_RETURN_ERROR
		Endif
	Next i

	DynamicDllLoader=hDll
	ExitFunction
*DDL_RETURN_ERROR
	DynamicDllLoader=0
	if hDll<>0 Then FreeLibrary(hDll)
	if errMes<>0 Then 
		MessageBox(hWnd,errMes,"DLLロードエラー",MB_ICONERROR)
		free(errMes)
	endif
EndFunction

'バイナリに実行可能属性追加
Function SetAsm(asm As *Byte, codesize As Long) As VoidPtr
	SetAsm=VirtualAlloc(NULL, codesize, MEM_COMMIT, PAGE_EXECUTE_READWRITE) '追加
	memcpy(SetAsm,asm,codesize)
End Function

'↑開放
Sub FreeAsm(func As VoidPtr)
	VirtualFree(func, 0, MEM_DECOMMIT or MEM_RELEASE) '追加
End Sub

/*
 * cdeclの関数呼び出しができる関数
 * 引数 ：FuncAdr	-> CDECL関数のアドレス
 *		：params	-> 引数（DWord）のリスト
 * 		：nParam	-> 引数の個数
 * 戻り値はその関数の戻り値
 * 機械語のソースは別ファイル参照
*/
TypeDef Type_cdeclLoader = *Function(FuncAdr AS VoidPtr , params AS *DWord,nParam AS Byte) As DWord
Function Load_cdeclLoader() AS Type_cdeclLoader
	Dim _cdeclLoader_bin[ELM(&H8F)]=[
	&H55,&H89,&HE5,&H83,&HEC,&H20,&H8A,&H45,&H10,&H8B,&H4D,&H0C,&H8B,&H55,&H08,&H88,&H45,
	&HFB,&H89,&H4D,&HF4,&H89,&H55,&HF0,&H0F,&HB6,&H4D,&HFB,&HC1,&HE1,&H02,&H89,&H4D,&HEC,
	&H83,&H7D,&HF4,&H00,&H0F,&H84,&H39,&H00,&H00,&H00,&H0F,&HB6,&H45,&HFB,&H89,&H45,&HE8,
	&H83,&H7D,&HE8,&H00,&H0F,&H84,&H23,&H00,&H00,&H00,&H8B,&H45,&HE8,&H83,&HE8,&H01,&H8B,
	&H4D,&HF4,&H8B,&H04,&H81,&H89,&H45,&HE4,&HFF,&H75,&HE4,&H89,&H45,&HFC,&H8B,&H45,&HE8,
	&H83,&HC0,&HFF,&H89,&H45,&HE8,&HE9,&HD3,&HFF,&HFF,&HFF,&HE9,&H00,&H00,&H00,&H00,&H90,
	&HFF,&H55,&HF0,&H03,&H65,&HEC,&H89,&H45,&HE0,&H89,&H45,&HFC,&H8B,&H45,&HE0,&H83,&HC4,
	&H20,&H5D,&HC2,&H0C,&H00] As Byte

	'↑を実行可能領域へ転送
	Load_cdeclLoader=VirtualAlloc(NULL, &H8F, MEM_COMMIT, PAGE_EXECUTE_READWRITE)	
	if Load_cdeclLoader=0 Then ExitFunction
	memcpy(Load_cdeclLoader,_cdeclLoader_bin,&H8F)
End Function

'------------------------------
'		Console library
'------------------------------

Function GetConsoleCursorDw() AS DWord
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	memcpy(VarPtr(GetConsoleCursor),CmdPos.dwCursorPosition,sizeof(DWord))
EndFunction

SUb GetConsoleCursor(ByRef pos AS COORD)
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	memcpy(VarPtr(pos),VarPtr(CmdPos.dwCursorPosition),sizeof(DWord))
EndSub

Sub ConsoleReturnLine()
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	CmdPos.dwCursorPosition.X=0
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	
EndSub

Sub ConsoleLocateRelative(x As Long,y AS Long)
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos) AS DWORD)
	CmdPos.dwCursorPosition.X += x
	CmdPos.dwCursorPosition.Y += y
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	
EndSub

Sub ConsoleClearCurrentLine()
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos) AS DWORD)
	CmdPos.dwCursorPosition.X = 0
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	
	print String$(CmdPos.dwSize.X," ")
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	

EndSub

Sub ConsoleReturnChar(count AS Long)
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	CmdPos.dwCursorPosition.X-=count
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	
EndSub

'コンソールのウィンドウハンドルを取得
Function GetConsoleWndHandle() AS HANDLE
	dim hConsole As HWND
	SetConsoleTitle("_FIND_STRING_RGBA_CRT_") 
	Sleep(40) 
	hConsole=FindWindow(NULL, "_FIND_STRING_RGBA_CRT_")
EndFunction

'コンソールのアイコンを変更
Sub SetConsoleIcon(IconID AS DWord)
	SendMessage(GetConsoleWndHandle(),WM_SETICON,ICON_SMALL,LoadImage(GetModuleHandle(0),IconID As BytePtr,IMAGE_ICON,GetSystemMetrics(SM_CXSMICON),GetSystemMetrics(SM_CYSMICON),LR_DEFAULTCOLOR) As Long)
EndSub

Const PRINTF_BUFFER = 1025
Sub printf(lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord )
	Dim Buf[PRINTF_BUFFER] AS Byte,ret AS Long
	ret=wsprintf(Buf,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	PrintPtr(Buf,ret)
EndSub

Sub PrintPtr(Text As BytePtr)(Length AS Long)
	Dim a AS Long
	if Length=0 then 
		a=lstrlen(Text)
	Else
		a=Length
	End If
	WriteFile(_System_hConsoleOut,Text,a,VarPtr(a),ByVal NULL)
	'WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),Text,Length,NULL
Endsub

Sub PauseConsole()
	Dim buf AS DWord
	WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),ex"[PRESS ANY KEY]\0",16,VarPtr(buf),ByVal NULL)
	ReadFile(GetStdHandle(STD_INPUT_HANDLE),VarPtr(buf),1,VarPtr(buf),ByVal NULL)
EndSub

Function Dump(Data As BytePtr,Size As DWORD)(VAdr As DWORD,noHeader AS BOOL) AS DWORD
	Dim Tmp[&H20] As Byte,i As Long,Adr As DWORD
	
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), BACKGROUND_BLUE OR BACKGROUND_GREEN OR BACKGROUND_RED)
	if VAdr=0 Or noHeader=FALSE then Print " ADDRESS  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  0123456789ABCDEF "
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 1 OR 2 OR 3 OR 4)
	Do
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), BACKGROUND_BLUE  OR 4 OR 3 )
		printf("%08X  ",Adr+VAdr)
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 1 OR 2 OR 3 OR 4)
'		Print " ";
		For i=0 To &H0F
			if Adr+i=>Size then
				printf("-- ",0)
			Else 
				printf("%02X ",Data[Adr+i])
			endif
		Next i
		Print " ";
		For i=0 To &H0F
			if Adr+i=>Size then Goto *EXIT_LOOP
			if Data[Adr+i]<&H20 or Data[Adr+i]=&HFF then 
				Print ".";
			Else
				printf("%1c",Data[Adr+i])
			Endif
		Next i
		i=0
		Adr+=&H10
		if Adr+i=>Size then Goto *EXIT_LOOP
		Print
	Loop
*EXIT_LOOP
	Print
'	Print Hex$(Adr*&H10+i)+"="+Hex$(Size)
	Dump=Adr
Endfunction




'---------------
'	Device 
'---------------
Function SetIOTimeOut(hComPortPort AS HANDLE,TimeOut AS DWord) AS Byte
	Dim ct AS COMMTIMEOUTS
	ct.ReadIntervalTimeout=TimeOut		'連続受信タイムアウト
	ct.ReadTotalTimeoutConstant=TimeOut	'Constant+Multiplier*バイト数＝タイムアウト
	ct.ReadTotalTimeoutMultiplier=20
	ct.WriteTotalTimeoutConstant=TimeOut
	ct.WriteTotalTimeoutMultiplier=20

	SetCommTimeouts(hComPortPort,VarPtr(ct))
EndFunction

'---------------
'	Math
'---------------
Function isNan(value AS double) AS Double
	Dim dw[1] AS DWord
	memcpy(dw,VarPtr(value),8)

	if (((dw[1])>>(20) And &H7FFF)=2047) And (dw[0] or (dw[1] And &H0007FFFF))>0 Then
		isNan=TRUE
	End If
End Function

Function Nan() AS Double
	Dim DWORD_H=&H7FF55577 AS DWord
'	Dim DWORD_L=&HFF005599 AS DWord
	memcpy(VarPtr(Nan)+4,VarPtr(DWORD_H),4)
'	memcpy(VarPtr(Nan)  ,VarPtr(DWORD_L),4)
End Function

/* bibun 関数の微分係数を出す
 * 	_func  : 微分したい関数へのポインタ
 *	inValue: 関数へ渡す値
 *	return = 微分係数
 */
Typedef FN_PROTO = *Function(x AS Double) AS Double
Function bibun(_func AS FN_PROTO,inValue AS Double) AS Double
	bibun = (_func(inValue + EPS) - _func(inValue)) / EPS
End Function

Function newton(x1 AS double,func AS FN_PROTO) AS double
	Dim x AS double,xp AS double,fdash AS double,  c AS Long
	x=x1
	Do
		xp=x

		fdash=bibun(func,xp)
		if fdash=0 Then fdash=EPS
		x = xp - (func(xp) / fdash)
		if Abs(x-xp) < EPS or c>ITER_LIMITTER Then ExitDo
		c++
	Loop

	newton=x
End Function

Function GetKaiLU(ByRef A AS ABMatrix,ByRef b AS ABMatrix) AS *ABMatrix
	Dim L AS *ABMatrix,U AS *ABMatrix
	Dim y AS *ABMatrix,tmp AS *ABMatrix
	Dim sigma AS DOUBLE,i as Long,k AS Long
	x=new ABMatrix(b.y,b.x)
	y=new ABMatrix(b.y,b.x)

	A.GetLU(L,U)	
	For i = 0 To y->y-1
		sigma=0
		For k=0 To i-1
			sigma+=L->Get(i,k)*y->Get(k,0)
		Next k
		y->Set((b.Get(i,0)-sigma)/L->Get(i,i),i,0)
	Next i 

	For i = y->y-1 To 0 Step -1
		sigma=0
		For k=i To y->y-1
			sigma+=U->Get(i,k)*x->Get(k,0)
		Next k
		x->Set((y->Get(i,0)-sigma)/U->Get(i,i),i,0)
	Next i

	GetKaiLU=x
	delete y	:	delete L	:	delete U
End Function


Function MulMatrix(ByRef a AS ABMatrix,ByRef b AS ABMatrix) AS *ABMatrix
	Dim ix AS Long,iy AS Long,is AS Long
	Dim sum AS double
	Dim ret AS *ABMatrix
	ret=new ABMatrix(b.y,b.x)

	For iy=0 To ret->y-1
		For ix=0 To ret->x-1
			sum=0
			For is=0 To a.x-1
				sum+=a.Get(iy,is) * b.Get(is,ix)	
			Next is
			ret->Set( sum ,iy,ix)
		Next ix
	Next iy
	MulMatrix=ret
End Function

Function InputMatrix()(Message AS BytePtr) AS *ABMatrix
	Dim in AS String
	Dim x AS Long,ox AS Long,i As Long, y AS Long,dr[20] AS *double
	if Message<>0 Then printf(ex"%s\n",Message)
	Do
		Input ">",in
		dr[y]=Str2DoubleAry(in,x)
		if dr[y]=NULL or x=0 Then Exitdo
		if i>0 And ox<>x Then Print "行列サイズが不正です。":ExitFunction
		ox=x
		i++:y++
		if y>20 then Print "行数制限です。":Exitdo
	Loop
	'サイズが0
	if y<1 or ox<1 Then 
		For i=0 To y-1
			free(dr[i])
		Next i
		ExitFunction
	Endif

	InputMatrix=new ABMatrix(y,ox)
	For i=0 To y-1
		For x=0 To ox-1
			InputMatrix->Set(dr[i][x],i,x)
		Next x
		free(dr[i])
	Next i

	Print
End Function

Function Str2DoubleAry(str AS BytePtr,ByRef count AS Long) AS *double	debug
	Dim i aS Long,C AS Long
	
	count=0
	if str=NULL then ExitFunction
	Str2DoubleAry=calloc(sizeof(double)*lstrlen(str)+10)

	Do
		if str[i]=0 Then ExitDo
		if str[i]<>Asc(" ") Then 
			Str2DoubleAry[C]=Val(str+i)
			C++
			'Skip to next space
			Do
				i++
				if str[i]=Asc(" ") Then Exitdo
				if str[i]=0 Then exitdo
			Loop
			continue
		End If
		i++
	Loop

	if C>0 Then
		realloc(Str2DoubleAry,sizeof(double)*(C))
		count=C
	Else
		free(Str2DoubleAry)
		Str2DoubleAry=0
	Endif
End Function

Function CountChar(str AS BytePtr,chara AS Byte) AS Long
	if str=NULL then ExitFunction
	Dim i aS Long,C AS Long
	Do
		if str[i]=chara Then C++
		if str[i]=0 Then ExitDo
		i++
	Loop
	CountChar=C
End Function






'------------------------------
'		Class library
'------------------------------

'コマンドライン分割ライブラリ
Class CommandLine
private 
	cmdStr AS BytePtr
	count as Long
	table AS *BytePtr

	Sub freeMem()
		if cmdStr<>0 Then free(cmdStr):cmdStr=0
		if table<>0 Then free(table):table=0
		count=0
	EndSub

	Function SkipDQ(text AS BytePtr,txlen AS Long,offset AS Long) AS Long
	'	Print
		Dim i AS Long
		For i = offset To txlen
			if text[i]=Asc(ex"\q") then ExitFor	
		Next i
		SkipDQ=i-offset+1
	End Function
Public
	Sub CommandLine()(text As BytePtr)
		if text=0 Then
			ParseCommandLine(GetCommandLine())
		Else
			ParseCommandLine(text)
		endif
	EndSub
	Sub ~CommandLine()
		freeMem()
	EndSub

	Function GetCount() AS Long
		GetCount=count
	EndFunction

	Function GetCmd(index AS DWord) AS BytePtr
		if index>count-1 Then GetCmd="":ExitFunction
		GetCmd=table[index]
	EndFunction

	Function GetCmdString(index AS DWord) AS String
		GetCmdString=MakeStr(table[index])
	EndFunction

	'コマンドラインオプションチェック用
	Function cmpCmd(index As DWord,cmptext As BytePtr) As Byte
		if index>count Then cmpCmd=FALSE : ExitFunction
		if lstrcmpi(table[index],cmptext)=0 Then
			cmpCmd=TRUE
		Else
			cmpCmd=FALSE
		endif
	Endfunction

	Function ParseCommandLine(text AS BytePtr) AS Long
'		OutputDebugString(ex"called\n")
		if cmdStr<>0 Then freeMem()
		'確保
		Dim txlen AS Long
		txlen=lstrlen(text)
		cmdStr=calloc(txlen+5)
		memcpy(cmdStr,text,txlen+1)

		'スペースを数える
		Dim ExpectedCount=0 As Long
		Dim i aS Long
		For i = 0 To txlen
			if cmdStr[i]=Asc(" ") Then 
				ExpectedCount++
			endif
		Next i

		'スペースの分だけテーブルを確保,構築
		table=calloc(sizeof(BytePtr)*(ExpectedCount+2)+4)
		count = 0

		Dim it=0 AS Long	'table index
		For i = 0 To txlen-1
			if cmdStr[i]<>Asc(" ") and cmdStr[i]<>0 Then
				'register to table
				table[it]=cmdStr+i
				it++

				For i = i To txlen
					if cmdStr[i]=Asc(" ") Then Exitfor
					if text[i]=Asc(ex"\q") then	i+=SkipDQ(cmdStr,txlen,i+1)':Print "!"
				Next i

				'tarminate 1 opt
				cmdStr[i]=0
			endif 
		Next i
		count=it
		it++
		table[it]=0
	EndFunction
End Class
/*
	1.空白以外の文字発見＝有効な文字列の先頭　-＞　テーブルに保存
	2.次のスペースまでスキップ
		2.5 そのうちにダブルクォーテーション見つけたら、スキップ -> DQ内のスペースは分割されない
	3.goto 1 (ｺﾚにより、余分なスペースがいなくなる)

*/

'ファイルパス用クラス
Class FilePath
Private
	pathStr AS StringClass
	pNull AS DWord
Public
	'ファイルかフォルダかはわからないけどパスがセットされた
	Sub SetPath(path As BytePtr)
		'ダブルクォーテーションを削除しつつメモリ確保＆格納
		pathStr.set(DelDQ(path))
		pNull=pathStr.length()
	EndSub

	'フォルダを一階層下げるなどの用途がある
	Sub PushDir(SubDir As BytePtr)
		if pathStr.ptr[pNull-1]=Asc("\") Then
			pathStr.cat(SubDir)
			pathStr.cat("\")
		Else
			pathStr.cat(SubDir)
			pathStr.cat("\")
		Endif
	EndSub

	Sub PopDir()
		Dim i As Long
		For i = pathStr.length()-2 To 0 Step -1
			if pathStr.ptr[i]=Asc("\") Then	ExitFor
			if pathStr.ptr[i]=Asc(":") Then ExitSub
		Next i
		pathStr.TerminateChar(i+1)
		'Base[i+1]=0
	EndSub
	
	Sub cat(text as BytePtr)
		pathStr.cat(text)
	EndSub

	Function isExist() AS Long
		isExist=PathFileExists(pathStr.ptr)
	EndFunction

	Function isDir() AS Long
		if PathIsDirectory(pathStr.ptr) Then 
			isDir=FALSE
		Else
			isDir=TRUE
		Endif
	EndFunction

	Function GetPathString() AS String
		GetPathString=pathStr.getString()
	EndFunction

	Function GetPath() AS BytePtr
		GetPath=pathStr.ptr
	EndFunction

	Function GetFileName() AS BytePtr
		GetFileName=PathFindFileName(pathStr.ptr)
	EndFunction

	Function GetFileExt() AS BytePtr
		GetFileExt=PathFindExtension(pathStr.ptr)
	EndFunction

	Function GetFileDirString() AS String
		Dim tmp AS BytePtr
		pathStr.copyToNewPtr(tmp)
		PathRemoveFileSpec(tmp)
		GetFileDirString=MakeStr(tmp)
		free(tmp)
	EndFunction

	Sub Destroy()
		pathStr.freeStr()
		pNull=0
	EndSub

	Sub ~FilePath()
		Destroy()
	EndSub
End Class


'EasyIOのクラス版
Class File
Private
	hFile As HANDLE
Public
	path AS FilePath
	Function openFile(inPath As BytePtr,_Mode AS DWORD) AS Long
		Dim CreateMode AS Dword
		If _Mode=GENERIC_READ then
			CreateMode=OPEN_EXISTING
		Elseif  _Mode=GENERIC_WRITE then
			CreateMode=CREATE_ALWAYS
	    Else
	    	CreateMode=OPEN_EXISTING
		EndIf

		hFile=CreateFile(inPath, _Mode, FILE_SHARE_READ or FILE_SHARE_WRITE, ByVal 0,CreateMode, FILE_ATTRIBUTE_NORMAL, 0)
		If hFile=INVALID_HANDLE_VALUE then 
			openFile = FALSE
			hFile=0
		Else
			openFile = TRUE
		Endif
		path.SetPath(inPath)
	EndFunction

	Function read(dest AS BytePtr,size As DWord) AS Long
	     Dim dwAB As BytePtr
	     read=ReadFile(hFile,dest,size,VarPtr(dwAB),ByVal NULL) As Long
	     If read=TRUE And dwAB=0 then
	          read=-1 As Long
	     ElseIf read=FALSE then
	          read=-2 As Long
	     Else
	          read=dwAB AS Long
	     EndIf
	End Function

	Function readDw() AS Long
		read(VarPtr(readDw),sizeof(DWord))
	End Function

	Function write(source AS BytePtr,size As DWord) AS Long
		WriteFile(hFile,source,size,VarPtr(write),ByVal NULL)
	End Function

	Function getFilePtr() AS DWord
		getFilePtr=SetFilePointer(hFile,0,0,FILE_CURRENT)
	EndFunction

	Sub setFilePtr(fp AS DWord)
		SetFilePointer(hFile,fp,0,FILE_BEGIN)
	End Sub

	Sub addFilePtr(fp AS DWord)
		SetFilePointer(hFile,fp,0,FILE_CURRENT)
	End Sub

	Function length() AS Long
		if hFile = 0 Then length=-1 : Exitfunction
		length=GetFileSize(hFile,NULL)
	EndFunction

	Function getHandle() AS HANDLE
		getHandle=hFile
	EndFunction

	Function getPath() AS BytePtr
		getPath=path.GetPath()
	EndFunction

	Sub close()
		CloseHandle(hFile)
		hFile=0
		path.Destroy()
	End Sub
End Class


'速度重視の文字列クラス
Const STRCLASS_SPF_BUFFER = 1024
Class StringClass
Private
	pNull As DWord
	size AS DWord
Public
	ptr AS BytePtr

	Function cat(text AS BytePtr) AS Long
		Dim txlen AS DWord
		txlen=lstrlen(text)
		if pNull+txlen >= size Then allocStr(txlen+size)
		memcpy(ptr+pNull,text,txlen)
		pNull+=txlen
		ptr[pNull]=0
	EndFunction

	Function cpy(text AS BytePtr) AS Long
		Dim txlen AS DWord
		txlen=lstrlen(text)
		if txlen > size Then allocStr(txlen)
		memcpy(ptr,text,txlen)
		pNull=txlen
		ptr[pNull]=0
	EndFunction

	Function length() AS DWord
		length=pNull
	EndFunction

	Function cmp(text AS BytePtr) AS Long
		cmp=lstrcmp(ptr,text)
	EndFunction
	Function cmpi(text AS BytePtr) AS Long
		cmp=lstrcmp(ptr,text)
	EndFunction

	Function sprintf(lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord )
		Dim txlen AS DWord
		txlen=lstrlen(lpFormat)
		if txlen+STRCLASS_SPF_BUFFER+pNull > size then allocStr(txlen+STRCLASS_SPF_BUFFER+pNull)
		pNull+=wsprintf(ptr+pNull,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	EndFunction

	Sub set(text AS BytePtr)
		freeStr()
		ptr=text
		pNull=lstrlen(text)
		size=pNull
	EndSub

	Sub copyToNewPtr(ByRef dest As BytePtr)
		dest=calloc(pNull+2)
		memcpy(dest,ptr,pNull+1)
	endSub

	Sub update()
		pNull=lstrlen(text)
		size=pNull
	EndSub

	Sub TerminateChar(pos As DWord)
		ptr[pos]=0
		pNull=pos
	EndSub

	'あとはUnicode系とか、文字列検索とか必要になったら実装 

	Sub allocStr(newSize AS DWord)
		size=newSize+5
		if ptr=0 Then 
			ptr=calloc(size)
		Else
			ptr=realloc(ptr,size)
		Endif
	EndSub

	Sub freeStr()
		if ptr<>0 Then free(ptr):ptr=0
		pNull=0
		size=0
	EndSub

	Sub saveMem()
		ptr=realloc(ptr,pNull+1)
		size=pNull+1
	EndSub

	Function getString() AS String
		getString=MakeStr(ptr)
	EndFunction

	Sub ~StringClass()
		freeStr()
	EndSub

End Class

'自分のEXEファイルがあるディレクトリを扱う
Class BinalyDirectory
Private
	BinalyRoot AS BytePtr
	TempString AS BytePtr
	p AS Word
Public
	Sub BinalyDirectory()
		Dim exePath[MAX_PATH+1] AS Byte,i AS Long
		GetModuleFileName(NULL,exePath,MAX_PATH)
		For i = lstrlen(exePath) To 0 Step -1
			If exePath[i]=&H5C then ExitFor' \ だったら
		Next i
		i++
		exePath[i]=0'￥以下を潰す
		BinalyRoot=calloc(i+2)
		memcpy(BinalyRoot,exePath,i+1)
		p=(i+1) AS Word
	EndSub

	Sub ~BinalyDirectory()
		if BinalyRoot<>0 Then free(BinalyRoot)
		if TempString<>0 Then free(TempString)
	EndSub

	Function GetBinDir() AS BytePtr
		GetBinDir=BinalyRoot
	End Function

	Function MakePath(subPath AS BytePtr) AS BytePtr
		freeTmp()
		TempString=calloc(p+lstrlen(subPath)+1)
		wsprintf(TempString,"%s%s",BinalyRoot,subPath)
		MakePath=TempString
	End Function

	Function GetMadePath() AS BytePtr
		GetMadePath=TempString
	EndFunction

	Sub freeTmp()
		if TempString<>0 Then free(TempString):TempString=0
	EndSub
End Class

Class ABMatrix
Public
	x AS Long	'列数
	y AS Long 	'行数
Private
	pMatrix AS *Double
Public
	Sub ABMatrix(iny AS Long,inx AS Long)(initMatrix As *Double)
		x=inx
		y=iny
		pMatrix=malloc(sizeof(double)*inx*iny)
		if initMatrix<>NULL Then
			memcpy(pMatrix,initMatrix,sizeof(double)*inx*iny)
		Else
			FillMemory(pMatrix,sizeof(double)*inx*iny,0)
		End If
	End Sub

	Sub ~ABMatrix()
		free(pMatrix) 	:	pMatrix=NULL
	End Sub

	Sub PrintMatrix()(caption AS BytePtr)
		if caption=NULL Then caption=""
		printf(ex"%sMatrix[%08X,%d,%d] : \n",caption,pMatrix,x,y)
		Dim ix AS Long,iy AS Long
		For iy=0 To y-1
			For ix= 0 To x-1
				printfd(ex"%5.2f\t",pMatrix[ix+iy*x])
			Next ix
			Print
		Next iy
		Print ex"-------------------------------\n"
	End Sub

	Sub Overwrite(newMatrix As *Double) 	'double配列から入力
		if newMatrix<>NULL Then
			memcpy(pMatrix,newMatrix,sizeof(double)*x*y)
		End If
	End Sub

	Function Get(pos_y AS Long,pos_x AS Long) AS double
		Get=pMatrix[pos_x+pos_y*x]
	End Function

	Sub Set(value AS double,pos_y AS Long,pos_x AS Long)
		pMatrix[pos_x+pos_y*x]=value
	End Sub

	Sub MakeUnitMatrix()	'現在の行列を破棄し単位行列にする
		Dim ix AS Long,iy AS Long
		For iy=0 To y-1
			For ix= 0 To x-1
				if ix=iy Then
					pMatrix[ix+iy*x]=1
				Else
					pMatrix[ix+iy*x]=0
				End If
			Next ix
		Next iy
	End Sub

	'小行列を取得, excludeした行, 列を除去した行列を返す
	Function GetSubMatrix(excludeX AS Long,excludeY AS Long) AS *ABMatrix
		Dim ret AS *ABMatrix 
		ret=new ABMatrix(x-1,y-1)

		Dim ix AS Long,iy AS Long,nx AS Long,ny AS Long
		For iy=0 To y-1
			if iy=excludeY Then Continue
			For ix= 0 To x-1
				if ix=excludeX Then Continue
				ret->Set(pMatrix[ix+iy*x],ny,nx)
				nx++
			Next ix
			nx=0
			ny++
		Next iy
		GetSubMatrix=ret
	End Function

	'行列式detを求める
	Function determinant() AS double
		if x=<1 and y=<1 Then	determinant=pMatrix[0]:ExitFunction
		if x<>y Then ExitFunction
		Dim i AS Long,ret AS double
		Dim work AS *ABMatrix
		For i=0 To x-1
			work=GetSubMatrix(i,0)
			if i Mod 2 = 0 Then
				ret += pMatrix[i] * work->determinant()
			Else
				ret -= pMatrix[i] * work->determinant()
			End If
			delete work
		Next i
		determinant=ret
	End Function

	'行列式による逆行列取得（PDF参照）
	Function GetInverseMatrix() AS *ABMatrix
		Dim ix AS Long, iy AS Long, sign AS double
		Dim retMx As *ABMatrix, subMx AS *ABMatrix, detM AS double
		if x=<1 and y=<1 Then	GetInverseMatrix=NULL:ExitFunction

		retMx = new ABMatrix(x,y)	'戻り値の行列
		detM=determinant()
		
		For iy=0 To y-1
			For ix= 0 To x-1
				subMx=GetSubMatrix(iy,ix)	'小行列取得
				if ix Mod 2=iy Mod 2 Then	'＋−で縞々に　偶数&偶数 or 奇数＆奇数
					sign=1
				Else
					sign=-1
				End if
				retMx->Set(sign*subMx->determinant()/detM,iy,ix)	'符号 * det(小行列) / detM
				delete subMx
			Next ix
		Next iy
		GetInverseMatrix=retMx
	End Function

	'LU分解したものを取得(PDF準拠)
	Sub GetLU(ByRef LMatrix AS *ABMatrix,ByRef UMatrix AS *ABMatrix)
		Dim retL AS *ABMatrix,retU AS *ABMatrix
		Dim ix AS Long,iy AS Long,w AS Long, sigma AS double

		retL=new ABMatrix(x,y)
		retU=new ABMatrix(x,y)

		For iy=0 To y-1
			For ix= 0 To x-1
				'L
				if ix=<iy Then
					if ix=0 Then 
						retL->Set(pMatrix[iy*x],iy,0)
					Elseif ix=iy Then
						'シグマの計算
						sigma=0
						For w=0 To ix-1
							sigma+=retL->Get(iy,w) * retU->Get(w,ix)
						Next w								
						retL->Set(pMatrix[ix+iy*x]-sigma,iy,ix)
					Else
						'斜め(ix=iy以外)、先頭列(ix=0)以外の時つまりL(i,k)
						sigma=0
						For w=0 To ix-1
							sigma+=retL->Get(iy,w) * retU->Get(w,ix)
						Next w
						retL->Set(pMatrix[ix+iy*x] - sigma,iy,ix)
					End If
				End If

				'U
				if ix=>iy Then
					if ix=iy Then 
						retU->Set(1,ix,iy)	'u(i,i)=1
					Elseif iy=0 Then
						retU->Set(pMatrix[ix]/pMatrix[0],0,ix)
					Else
						'斜め以外で1行目以外の時
						sigma=0
						For w=0 To ix-1
							sigma+=retL->Get(iy,w) * retU->Get(w,ix)
						Next w
						retU->Set((pMatrix[ix+iy*x]-sigma)/retL->Get(iy,iy),iy,ix)
					End If
				End If				
			Next ix
		Next iy

		if VarPtr(LMatrix)<>NULL Then
			LMatrix=retL
		Else
			delete LMatrix
		End If
		if VarPtr(UMatrix)<>NULL Then
			UMatrix=retU
		Else
			delete UMatrix
		End If
	End Sub

	'ガウス消去法による逆行列取得
	Function GaussInverse() AS *ABMatrix
		Dim ret AS *ABMatrix,tmp AS *ABMatrix
		Dim ix AS Long,iy AS Long,sx AS Long
		Dim coff AS double

		ret=new ABMatrix(y,x)	'右側の行列　最初は単位行列
		ret->MakeUnitMatrix()
		tmp=new ABMatrix(y,x)	'左側のコピー
		tmp->Overwrite(pMatrix)

		For ix=0 To x-1
			'ターゲットを割り算で１にする
			coff=tmp->Get(ix,ix)
			if coff<>1 then
				For sx = 0 To x-1
					tmp->Set(tmp->Get(ix,sx)/coff,ix,sx)
					ret->Set(ret->Get(ix,sx)/coff,ix,sx)
				Next sx
			End If

			'ターゲット行以外のターゲット列を0にする
			For iy=0 To y-1
				if iy<>ix Then
					coff=tmp->Get(iy,ix)
					For sx = 0 To x-1
						'更新セル = 更新セル     - 消したいとこ　 × 今の列の1にしたいとこ（ix=iy） 
						tmp->Set(tmp->Get(iy,sx) - tmp->Get(ix,sx) * coff ,iy,sx)
						ret->Set(ret->Get(iy,sx) - ret->Get(ix,sx) * coff ,iy,sx)
					Next sx
				End If
			Next iy
		Next ix

		GaussInverse=ret
		delete tmp
	End Function
End Class


'------------------------------------------------------
'			たぶんもう使わない関数
'------------------------------------------------------
'#include <EasyIO.sbp>
'Path にパス、ModeにGENERIC_READかGENERIC_WRITE
Function OpenFile(Path As BytePtr,_Mode AS DWORD) AS HANDLE
     Dim CreateMode AS Dword
     If _Mode=GENERIC_READ then
          CreateMode=OPEN_EXISTING
	Elseif  _Mode=GENERIC_WRITE then
		CreateMode=CREATE_ALWAYS
     Else
          CreateMode=OPEN_ALWAYS
     EndIf
     OpenFile=CreateFile(Path, _Mode, FILE_SHARE_READ or FILE_SHARE_WRITE, ByVal 0,CreateMode, FILE_ATTRIBUTE_NORMAL, 0)
     If OpenFile=INVALID_HANDLE_VALUE then OpenFile = -1 As VoidPtr
EndFunction

Function LoadFile(hFile As HANDLE,DataPtr As BytePtr,Size As DWORD) As BytePtr
     Dim dwAB As BytePtr
     LoadFile=ReadFile(hFile,DataPtr,Size,VarPtr(dwAB),ByVal NULL) As BytePtr
     If LoadFile=TRUE And dwAB=0 then
          LoadFile=-1 As BytePtr
     ElseIf LoadFile=FALSE then
          LoadFile=-2 As BytePtr
     Else
          LoadFile=DataPtr
     EndIf
EndFunction

Function OutFile(hFile As HANDLE,DataPtr As BytePtr,Size As DWORD)
     Dim dwAB As BytePtr
     OutFile=WriteFile(hFile,DataPtr,Size,VarPtr(dwAB),ByVal NULL)
EndFunction

Function GetFilePointer(hFile As HANDLE) As DWORD
     GetFilePointer=SetFilePointer(hFile,0,0,FILE_CURRENT)
EndFunction

'引数をNULLで区切る。NULL NULLで終わり (例）コマンド\0引数１\0"引数2"\0\0
Function MakeCmdLine(Text As BytePtr) as BytePtr
	Dim i AS DWORD,fDQ AS Byte,SP=-1 AS Long'-1でセット待ち
	dim dbg AS Byte
	dim  Buf As BytePtr,bi AS DWORD
	Const SPR=&H00'区切り文字NULL

	If Text=0 then ExitFunction
	Buf=calloc(lstrlen(Text)+4)
	
	For i = 0 To lstrlen(Text)
			If SP=-1 then
				If Text[i]<>&H20 then
					SP=i
					dbg=1
				Else
					Continue
				EndIf
			EndIf

			If fDQ=0 then
				If Text[i]=&H20 then
					memcpy(Buf+bi,Text+SP,i-SP)
					bi+=(i-SP)+1
					Buf[bi-1]=SPR
					SP=-1
				ElseIf Text[i]=0 then
					memcpy(Buf+bi,Text+SP,i-SP)
					bi+=(i-SP)+1
					Buf[bi-1]=SPR
				elseIf Text[i]=&H22 then'Doubleクォーテート
					fDQ=Not(fDQ)
				Else
			EndIf
			dbg=0
		Else
			If Text[i]=&H22 then'Doubleクォーテート
				fDQ=Not(fDQ)
			Else
			EndIf
		EndIf
	Next i
	Buf[bi]=0
	Buf[bi+1]=0
	MakeCmdLine=Buf
Endfunction

'↑で作られた文字列を扱う関数
'↑はNULLで区切られているので、lstrcpyみたいな関数が使える。
'この関数は指定した番号の引数をとってくる。
'EX) Text=cmd1\0cmd2\0opt1\0"path"\0\0
'2を指定すれば3つ目の「opt1」の開始アドレス0xAが返ってくる。MakeStr(Text+0xA)で「opt1」という文字列を取り出せる。
Function GetCmdAdr(Text AS BytePtr,Num As Byte) AS DWORD
	Dim i As DWORD,C As Byte
	If Num=0 then GetCmdAdr=0:ExitFunction
	Do
		If Text[i]=0 then
			If Text[i+1]=0 then GetCmdAdr=-1:ExitDo'ダブルNULL＝END
			C++
			If C=Num then GetCmdAdr=i+1:ExitDo
		EndIf
		i++
	Loop
Endfunction

Function FillString(Text As BytePtr,Buf As BytePtr,Num As DWord ,Max As DWord) As DWord
	Dim i As DWord/*,tSize As DWord*/,ti As DWord,nMake As DWord
'	tSize=lstrlen(Text)
	Do
		If i=>Max-1 OR nMake>=Num  then ExitDo
		Buf[i]=Text[ti]
		i++
		ti++
		If Text[ti]=0 then ti=0:nMake++
	Loop
	Buf[i]=0
	Buf[Max-1]=0
	FillString=i
EndFunction

'NULL文字記憶型strcat
Sub pstrcat(To As BytePtr,Src As BytePtr ,ByRef Ptr As DWORD)(Size As DWORD)
     If Size = 0 then Size=lstrlen(Src)
     memcpy(To+Ptr,Src,Size)
	'(free(Src)
     Ptr += Size
endsub

Function Lit2Big(Data As Word) As Dword
	Dim big[4] As Byte,In[3] As Byte
	memcpy(In,VarPtr(Data),2)
/*	big[0]=In[3]
	big[1]=In[2]
	big[2]=In[1]
	big[3]=In[0]*/
	big[0]=In[1]
	big[1]=In[0]
	memcpy(VarPtr(Lit2Big),big,2)
EndFunction
