'RGBA_CRT's Librarys
#include <RGBADef.sbp>
#include <EasyIO.sbp>
/*  Todo : 
		HTTP系をクラスに
*/


'--------------------------------------------------------
'	要求APIが環境依存（Win95デフォルトから外れるもの）
'--------------------------------------------------------

' %fが使える
Declare Function printfvc cdecl Lib "msvcrt.dll" Alias "printf" (str as BytePtr,format as BytePtr, ...) As Long
Declare Function printfd cdecl Lib "msvcrt.dll" Alias "printf" (format as BytePtr, v1 AS Double,...) As Long
Declare Function sprintfvc cdecl Lib "msvcrt.dll" Alias "sprintf" (str as BytePtr,format as BytePtr, ...) As Long
Declare Function sprintfd cdecl Lib "msvcrt.dll" Alias "sprintf" (str as BytePtr,format as BytePtr, d1 AS double,...) As Long


'---------------
'	Macros
'---------------
Const Abs16bit(b) = (b xor (b >> 15)) - (b >> 15) As Word
Const ChangeEndianWord(x) = ((x>>8) and &HFF) or (x and &HFF)<<8

'----------------------------
'		GUI Utility
'----------------------------
Sub PumpMessage() 
	Dim msg As MSG
 	while PeekMessage( msg, NULL, 0, 0, PM_REMOVE ) 
	TranslateMessage( msg )
	DispatchMessage( msg )
  	Wend
EndSub

Function GetDlgItemHex(hWnd AS HWND) AS Long
	Dim buf as BytePtr,Length AS Long
	Length=GetWindowTextLength(hWnd)
	buf=calloc(Length+5)
	GetWindowText(hWnd,buf,Length+1)
	Dim i as Long,mode as Long
	Do
		if buf[i]=&H20 Then 
			i++
			Continue'Skip Space
		Elseif buf[i]=&H30 Then	'0'
			if buf[i+1]=&H78 Or buf[i+1]=&H58 Then	'x'
				'16進決定,0xを&Hに変更
				buf[i]=&H26:	buf[i+1]=&H48
			EndIf
		EndIf
		ExitDo		
	Loop
	GetDlgItemHex=Val(buf+i) AS Long
	free(buf)
EndFunction

Function GetDlgItemDouble(hWnd AS HWND) AS Double
	Dim buf as BytePtr,Length AS Long
	Length=GetWindowTextLength(hWnd)
	buf=calloc(Length+5)
	GetWindowText(hWnd,buf,Length+1)
	GetDlgItemDouble=Val(buf)' AS Long
	free(buf)
EndFunction

'Auto Allocate
Function GetWndTextAA(hWnd AS HWND) AS BytePtr
	Dim buf as BytePtr,Length AS Long
	Length=GetWindowTextLength(hWnd)
	GetWndTextAA=calloc(Length+5)
	GetWindowText(hWnd,GetWndTextAA,Length+1)
EndFunction
/*
'エラーメッセージ表示
Function ErrMes(hOwner AS HWND,Text As BytePtr,Title As BytePtr,Flag As Dword) As Long
	SetForegroundWindow(hOwner)
	MessageBeep(MB_ICONHAND)
	ErrMes=MessageBox(hOwner,Text,ProgramName+" - "+MakeStr(Title),MB_ICONERROR Or Flag)
EndFunction*/

'エラーメッセージ表示(TST用)
Function ErrMes(hOwner AS HWND,Text As BytePtr,Title As BytePtr,Flag As Dword)(ErrCode As DWord) As Long
	SetForegroundWindow(hOwner)
	MessageBeep(MB_ICONHAND)
	if ErrCode=0 Then
		ErrMes=MessageBox(hOwner,Text,sprintfStr("%s - %s",ProgramName AS DWord,Title AS DWord),MB_ICONERROR Or Flag)
	'	DBM(Text)
	Else
		Dim SysErrMes AS BytePtr
		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER or FORMAT_MESSAGE_FROM_SYSTEM or FORMAT_MESSAGE_IGNORE_INSERTS, _
  			NULL, ErrCode, LANG_USER_DEFAULT, VarPtr(SysErrMes), 0, NULL)
		ErrMes=MessageBoxf(hOwner,ProgramName+" - "+MakeStr(Title),MB_ICONERROR Or Flag,ex"%s\nErrCode : %d\n%s",Text As DWord,ErrCode,SysErrMes AS DWord)
		free(SysErrMes)
	EndIf
EndFunction

'printfのMessageBox版
Function MessageBoxf(hWnd AS HWND,lpCaption AS BytePtr,uType AS DWord,lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord ) AS Long
	Dim buf[1024] As Byte	'wsprintfがそもそも1024バイトしか対応してない
	wsprintf(buf,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	MessageBoxf=MessageBox(hWnd,buf,lpCaption,uType)
EndFunction

'EXEC 終了コード取得
Function RunAndGetExitCode(App As BytePtr,CmdLine As BytePtr) AS Long
	Dim si AS STARTUPINFO 
	Dim pi As PROCESS_INFORMATION
	Dim Child As HANDLE
	Dim r As DWORD

	if CreateProcess(App,CmdLine,ByVal NULL,ByVal NULL,FALSE,CREATE_NEW_CONSOLE,NULL,NULL,si,pi)=FALSE Then'CREATE_NEW_CONSOLE を 0にすれば非表示
		RunAndGetExitCode=-1
		ExitFunction
	EndIf

	' 子プロセス起動成功
	Child = pi.hProcess

	' 不要なスレッドハンドルをクローズする
	CloseHandle(pi.hThread)

	' 子プロセスの終了待ち
	r = WaitForSingleObject(Child, INFINITE)
	if r<>WAIT_OBJECT_0 then
		'wait error!
		RunAndGetExitCode=-1
		ExitFunction
	EndIf

	' 子プロセスの終了コードを取得
	Dim exitCode As DWORD
	if GetExitCodeProcess(Child, exitCode)=FALSE then
		RunAndGetExitCode=-1
		ExitFunction
	EndIf

	if Child<>0 then CloseHandle(Child)
	RunAndGetExitCode=exitCode
EndFunction

'----------------------
'		Binaly
'----------------------

Function isSameBin(dat1 AS BytePtr, dat2 AS BytePtr,length aS DWord) AS BOOL
	Dim i  AS DWord
	For i = 0 To length-1
		if dat1[i]<>dat2[i] Then
			isSameBin=FALSE
			ExitFunction
		EndIf
	Next i
	isSameBin=TRUE
End Function

Sub ChangeEndianDW(ByRef in As DWord)
	Dim Tmp As Byte
	Dim value As *Byte
	value=VarPtr(in)
	Tmp=value[0]
	value[0]=value[3]
	value[3]=Tmp
	Tmp=value[1]
	value[1]=value[2]
	value[2]=Tmp
EndSub

Function Str2Dw(Data As BytePtr) As DWORD
	Str2Dw=GetDWord(Data)
	'memcpy(VarPtr(Str2Dw),Data,4)
EndFunction

Function Dw2Str(Data As DWORD) As String
	Dim Str[4] As Byte, i AS Long
	memcpy(Str,VarPtr(Data),4)
	For i = 0 To 3
		if Str[i] < &H20 Then Str[i]=&H20
	Next i
	Str[4]=0
	Dw2Str=MakeStr(Str)
EndFunction

'InStrのバイナリ版
Function InByteBin(Data As BytePtr,Size As DWORD,Bytes As Byte)(Jump AS Long) As Long
	Dim i As DWORD,tmp As Byte
	if Jump<>0 then i=Jump
	Do
		if Data[i]=Bytes Then InByteBin=i: ExitDo
		i++
		if i => Size then InByteBin=-1: ExitDo
	Loop
EndFunction

Function SwapWord(val AS Word) AS Word
	SwapWord = ((val<<8) And &HFF00) Or ((val>>8) And &H00FF) 
End Function

Function ReverseDWord(val As DWord) AS DWord
	'ABCD
	'D  D	; << 3
	' CC	; << 1
	' BB	; >> 1
	'A  A	; >>3
	ReverseDWord = ((val<<24) And &HFF000000) Or ((val<<8) And &H00FF0000)  Or ((val>>8) And &H0000FF00) Or ((val>>24) And &H000000FF) 
EndFunction


'---------------
'	Strings
'--------------


Function Wide2Ansi(utf16 AS WordPtr) AS BytePtr
'Function UTF16ToSJIS(utf16 AS WordPtr) AS BytePtr
	Dim l AS DWord
   ' UnicodeからShift-JISに変換
   l=WideCharToMultiByte(CP_ACP, 0, utf16, -1, 0, 0, 0, 0)
   Wide2Ansi=calloc(l)
   WideCharToMultiByte(CP_ACP, 0, utf16, -1, Wide2Ansi, l, 0, 0)
End Function

Function Ansi2Wide(ansi AS BytePtr) AS WordPtr
	Dim l As Long
	l=MultiByteToWideChar(CP_ACP, 0, ansi, -1, NULL, 0)
	Ansi2Wide=calloc(l*3)
	MultiByteToWideChar(CP_ACP, 0, ansi, -1, Ansi2Wide, l)
End Function

Function UTF8ToUnicode(utf8Str AS BytePtr) As BytePtr
	Dim l As Long
	l=MultiByteToWideChar(CP_UTF8, 0, utf8Str As WordPtr, -1, NULL, 0)
	UTF8ToUnicode=calloc(l*3)
	MultiByteToWideChar(CP_UTF8, 0, utf8Str, -1, UTF8ToUnicode, l)
End Function

Function UTF8ToSJIS(utf8Str AS BytePtr) As BytePtr
	Dim l As Long,uni AS BytePtr
	l=MultiByteToWideChar(CP_UTF8, 0, utf8Str, -1, NULL, 0)
	uni=calloc(l*3)
	UTF8ToSJIS=calloc(l*3)
	MultiByteToWideChar(CP_UTF8, 0, utf8Str, -1, uni, l)
	WideCharToMultiByte(CP_ACP,0,uni,-1,UTF8ToSJIS,l*3,0,0)
	free(uni)
End Function

Function UTF8toSJIS_Str(source As BytePtr) As String
   Dim u2s As BytePtr
   Dim u2s_out As BytePtr
   Dim l As Long
   
   ' UTF-8からUnicodeに変換
   l=MultiByteToWideChar(CP_UTF8, 0, source, -1, 0, 0)
   u2s_out=calloc(l*2+2)
   MultiByteToWideChar(CP_UTF8, 0, source, -1, u2s_out, l)
   
   ' UnicodeからShift-JISに変換
   l=WideCharToMultiByte(CP_ACP, 0, u2s_out, -1, 0, 0, 0, 0)
   UTF8toSJIS_Str=ZeroString(l)
   WideCharToMultiByte(CP_ACP, 0, u2s_out, -1, UTF8toSJIS_Str, l, 0, 0)
   
   ' 後始末
   free(u2s_out)
End Function


'BM法文字列サーチ（指定文字列内に特定の文字列があるか？＝True or false）(バグあり)
Function SerchTextLine(Src As BytePtr,Text As BytePtr,sLen As DWORD,isFirst As DWORD) As Byte
	Dim Skip[255] As DWORD
	Dim tLen As DWORD'(,sLen As DWORD
	Dim i As DWORD,j As Long,k As Long
	Dim letSkip As Byte, letLast As Byte
	Dim SP AS Long
	tLen=lstrlen(Text)
	if tLen=0 then 	SerchTextLine=FALSE:	ExitFunction
	For i=0 To 255 : Skip[i]=tLen :	Next i
	For i=0 To tLen-1 
		Skip[Text[i]]=tLen-1-i 
		if Skip[Text[i]]=0 then Skip[Text[i]]=1
	Next i
	tLen--
	letLast=Text[tLen]
	For i=tLen To sLen Step Skip[letSkip]
		letSkip=Src[i]
		if letSkip=letLast Then 
			j=i-1
			k=tLen-1
			While Src[j]=Text[k]
				if k=0 then 
					Goto *FOUND
				EndIf
				j--
				k--
			Wend
		EndIf
	Next i
	SerchTextLine=FALSE
	ExitFunction
*FOUND
	Dim Line As BytePtr
	Dim EP As Long
	SerchTextLine=TRUE
*RETRY
	if Src[j-SP]= &H0A Or Src[j-SP]=&H0D Then if isFirst<>0 then SP--: Goto *RETRY
	EP=InStrByte(Src+j,&H0D,sLen)'+j
	if EP=0 then EP=sLen
	if EP-SP<=1 then ExitFunction
EndFunction

'未デバッグ
Function FindStr(text AS BytePtr,size aS DWord,target AS BytePtr) aS Long
	Dim i AS Long,tarLen AS Long
	tarLen=lstrlen(target)
	Do
		if text[i]=target[0] Then
			if CompareString(LOCALE_SYSTEM_DEFAULT,0,text+i,tarLen,target,tarLen)=CSTR_EQUAL Then
				ExitDo
			Else
				i+=tarLen
			End If
		Else If text[i]=0 Then
			FindStr=-1
			ExitFunction
		End If
		i++
		if i>size Then ExitDo
	Loop
	FindStr=i
End Function

'この関数は作り直したほうがいい
Function InStrByte(Data As BytePtr,Serch As Byte,DataSize As DWORD) As Long
	Dim i as DWORD,si As Dword, sLen As Long
	Do
		if Data[i]=Serch then	InStrByte=i	: ExitDo
		if i=DataSize then
			InStrByte=-1
			ExitFunction
		EndIf
		i++
	Loop
EndFunction

'APIを使った高速バージョンのダブルクォーテーション抜き
Function DelDQ(Text As BytePtr) As BytePtr
	Dim tmp[MAX_PATH] AS Byte
	lstrcpy(tmp,Text)
	PathRemoveBlanks(tmp)
	PathUnquoteSpaces(tmp)

	Dim txlen AS DWord
	txlen=lstrlen(tmp)
	DelDQ=calloc(txlen+2)
	memcpy(DelDQ,tmp,txlen+1)
EndFunction

Function DelDQW(Text As WordPtr) As WordPtr
	Dim tmp[MAX_PATH] AS Word
	lstrcpyW(tmp,Text)
	PathRemoveBlanksW(tmp)
	PathUnquoteSpacesW(tmp)

	Dim txlen AS DWord
	txlen=lstrlenW(tmp)
	DelDQW=calloc(txlen*2+4)
	memcpy(DelDQW,tmp,txlen*2+2)
EndFunction

'LF,CR -> CRLF	戻り値は別メモリなので各自開放すること
Function ConvCRLF(Text As *Byte) As BytePtr
	Dim ti As Long
	dim ci as long
	Dim l as Long
	Dim lp as Long
	Dim CRLFD As *Byte

	ti=0
	ci=0

	l= lstrlen(Text)
	CRLFD=calloc2(l+5)

	Do
		if Text[ti] = &H0A then				'0A(LF)が発見され、
			if Text[ti-1] <> &H0D then		'0D(CR)その後ろがCR以外の場合
				CRLFD[ci]=&H0D				'CRを追加
				ci++
				l++
				lp++
				CRLFD=realloc2(CRLFD,l+lp*2)	'増えた分のメモリ確保
				CRLFD[ci]=&H0A				'そしてLFを追加
			Else
				CRLFD[ci]=&H0A				'違ったら（正しくCRLFになってたら）そのまま
			EndIf
		Elseif Text[ti] = &H0D then			'↑と大体同じ
			if Text[ti+1] <> &H0A then
				CRLFD[ci]=&H0D
				ci++
				l++
				lp++
				CRLFD=realloc2(CRLFD,l+lp*2)
				CRLFD[ci]=&H0A
			Else
				CRLFD[ci]=&H0D
			EndIf
		Else
			CRLFD[ci]=Text[ti]				'改行文字と無関係の場合
		EndIf 
		ti++
		ci++
		if ti = l Then ExitDo		
	Loop

	'メモリを確保し、戻り値をセット
	ConvCRLF=calloc2(lstrlen(CRLFD)<<1)
	lstrcpy(ConvCRLF,CRLFD)	

	'消す
	free2(CRLFD)
EndFunction

'strcmpの文字数指定バージョン
Function win_strncmpi(str1 AS BytePtr,str2 AS BytePtr,Length AS DWord) AS BOOL
	if CompareString(LOCALE_SYSTEM_DEFAULT,NORM_IGNORECASE,str1,Length,str2,Length) = CSTR_EQUAL Then
		win_strncmpi=TRUE
	Else
		win_strncmpi=FALSE
	EndIf
EndFunction

Function win_strncmp(str1 AS BytePtr,str2 AS BytePtr,Length AS DWord) AS BOOL
	if CompareString(LOCALE_SYSTEM_DEFAULT,0,str1,Length,str2,Length) = CSTR_EQUAL Then
		win_strncmp=TRUE
	Else
		win_strncmp=FALSE
	EndIf
EndFunction

'ファイルパスが正しいかチェック
Function IsFilePath(FilePath AS BytePtr) As BOOL
	Dim hFile AS HANDLE,dFilePath As BytePtr
	if FilePath[0]=&H22 Then 
		dFilePath=DelDQ(FilePath)
	Else
		dFilePath=FilePath
	EndIf
	hFile=CreateFile(dFilePath,GENERIC_READ,FILE_SHARE_READ OR FILE_SHARE_WRITE,ByVal NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL)
	If hFile=INVALID_HANDLE_VALUE Then
		IsFilePath=FALSE
	Else
		IsFilePath=TRUE
		CloseHandle(hFile)
	EndIf
	if FilePath<>dFilePath Then free(dFilePath)
EndFunction

'標準Windows
Function sprintfStr(lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord ) AS String
	Dim Buf[PRINTF_BUFFER] AS Byte,ret AS Long
	ret=wsprintf(Buf,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	sprintfStr=MakeStr(Buf)
EndFunction

'使うとVCランタイム要求になる
Function doubleToFormatStr(lpFormat As BytePtr)(a As Double) AS String
	Dim Buf[PRINTF_BUFFER] AS Byte,ret AS Long
	ret=sprintfd(Buf,lpFormat,a)
	doubleToFormatStr=MakeStr(Buf)
EndFunction

' =========================
' ファイルの容量などを単位付き文字列にする関数(64bit対応)
' =========================
Const DC2T_BUFFER_SIZE = 16
Function DataCap2Text(val AS QWord, text AS BytePtr, length AS DWord)(isLastDigit AS BOOL) AS BytePtr
	Dim buffer[DC2T_BUFFER_SIZE-1] AS Byte

	Const DC2T_UNIT_IDX_COUNT = 4
	Dim unitTable[DC2T_UNIT_IDX_COUNT] = ["Byte", "KB", "MB", "GB", "TB"/*, "PB", "EB"*/] As BytePtr
	Dim unitIndex AS Long
	Dim lastDigit AS Long
	Dim size As QWord
	Dim sign As BytePtr

	if val > &H8000000000000000 Then
		sign = "-"
		size = val * -1
	Else
		sign = ""
		size = val
	End If

	unitIndex = 0
	lastDigit = 0
	Do
		if size < 1024 Then ExitDo
		if unitIndex >= DC2T_UNIT_IDX_COUNT Then ExitDo
		lastDigit = ((size Mod 1024) * 10) / 1024
		size = size/1024
		unitIndex++
	Loop

	'QWordをcdeclの可変長引数に突っ込むと死ぬので
	Dim dwSize AS DWord
	dwSize = size
	if lastDigit=0 Or isLastDigit=FALSE Then
		wsprintf(buffer, ex"%s%d %s",sign,dwSize,unitTable[unitIndex])
	Else
		wsprintf(buffer, ex"%s%d.%d %s",sign,dwSize,lastDigit,unitTable[unitIndex])
	Endif

	if length < DC2T_BUFFER_SIZE Then
		memcpy(text, buffer, length)
	Else
		memcpy(text, buffer, lstrlen(buffer)+1)
	End If
	
End Function

' String型
Function DataCap2Text_Str(val AS QWord)(isLastDigit AS BOOL) As String
	Dim buffer[DC2T_BUFFER_SIZE-1] AS Byte
	DataCap2Text(val,buffer,DC2T_BUFFER_SIZE,isLastDigit)
	DataCap2Text_Str=MakeStr(buffer)
End Function

' Print
Sub PrintDataCap(val AS QWord)(isLastDigit AS BOOL)
	Dim buffer[DC2T_BUFFER_SIZE-1] AS Byte
	DataCap2Text(val,buffer,DC2T_BUFFER_SIZE,isLastDigit)
	PrintPtr(buffer)
End Sub


'------------------------------
'		Network library
'------------------------------

'URLのパーセントエンコードを解除
Function URLDecode(pFrom As BytePtr) As BytePtr
   	Dim i = 0 As DWord
	Dim ASCII As Byte
	URLDecode=calloc(MAX_PATH+5)

   Do 
		if pFrom[i]=&H25 Then '% then
			ASCII=Hex2Dec(Chr$(pFrom[i+1])+Chr$(pFrom[i+2])) AS Byte
			lstrcat(URLDecode , Chr$(ASCII))
			i=i+2
		Else
			lstrcat(URLDecode , Chr$(pFrom[i]))
		EndIf
		i++			
		if pFrom[i] = 0 Then ExitDo
   Loop
End Function

'軽量化のため、移動
'Function GetHttpStatusText(HttpStatusNo As Long)

'-------------------------------------
'  Dynamic DLL Loader + cdeclLoader
'-------------------------------------
Type DLL_FUNCTION_CELL
	'関数ポインタを格納するための変数へのポインタ
	ptr AS VoidPtr
	'DLLから探す関数名
	alias AS BytePtr
EndType

Function DynamicDllLoader(DllName AS BytePtr,func_list AS *DLL_FUNCTION_CELL,count AS Long)(opt_text AS BytePtr,hWnd AS HWND) As HINSTANCE
	Dim hDll AS HINSTANCE
	Dim errMes AS BytePtr

	hDll=LoadLibrary(DllName)
	if hDll=0 Then
		errMes=calloc(1024)
		if opt_text=0 Then opt_text=""
		wsprintf(errMes,ex"%s%sのロードに失敗しました。\nDLLが存在するか確認してください。\nErrorCode : %d",DllName,opt_text,GetLastError())
		Goto *DDL_RETURN_ERROR
	EndIf

	Dim i AS Long
	For i = 0 To count-1
		if func_list[i].ptr=0 or func_list[i].alias=0 Then Goto *DDL_RETURN_ERROR
		SetDWord(func_list[i].ptr,GetProcAddress(hDll,func_list[i].alias))	'Func_List.ptrの先に関数ポインタを格納
		if GetDWord(func_list[i].ptr)=NULL Then
			errMes=calloc(1024)
			if opt_text=0 Then opt_text=""
			wsprintf(errMes,ex"%sから必要な関数が見つかりませんでした。\n正しいバージョンのDLLか確認してください。\nProcName : %s\nErrorCode : %d",DllName,func_list[i].alias,GetLastError())
			Goto *DDL_RETURN_ERROR
		EndIf
	Next i

	DynamicDllLoader=hDll
	ExitFunction
*DDL_RETURN_ERROR
	DynamicDllLoader=0
	if hDll<>0 Then FreeLibrary(hDll)
	if errMes<>0 Then 
		MessageBox(hWnd,errMes,"DLLロードエラー",MB_ICONERROR)
		free(errMes)
	EndIf
EndFunction

'バイナリに実行可能属性追加
Function SetAsm(asm As *Byte, codesize As Long) As VoidPtr
	SetAsm=VirtualAlloc(NULL, codesize, MEM_COMMIT, PAGE_EXECUTE_READWRITE) '追加
	memcpy(SetAsm,asm,codesize)
End Function

'↑開放
Sub FreeAsm(func As VoidPtr)
	VirtualFree(func, 0, MEM_DECOMMIT or MEM_RELEASE) '追加
End Sub

' ==========================================
'  cdeclLoaderはabcdecl.sbpに引っ越しました
' ==========================================

/* ==========================================
 * arg() : 可変引数 -> 配列化関数
 * ==========================================
 *
 * 	ActiveBasicの可変引数は、省略部分を自動でゼロをセットするようになっている。
 *  printf的な関数を実装するときは省略可能引数を大量に並べる必要があるが、
 *  引数が1つであれ4つであれ、ゼロをセットする命令が大量に並ぶことになる。
 *  argは引数の数分だけ関数を用意することでゼロをセットする命令を削減することができる。
 *  詳しくは逆汗して
 *  ゼロをセットする処理よりこっちの方式のほうがメモリアクセスが多いので遅いかもしれない
 */

'スタックがそのまま配列になっているので、_argにコピーする
'スレッドセーフじゃないけど、滅多に使わないので現状このままで　
Typedef ARGT = Long
Dim _arg[15] As ARGT

Function arg() As *ARGT
	arg=_arg
End Function

Function arg(a As ARGT) As *ARGT
	_arg[0]=a
	arg=_arg
End Function

Function arg(a As ARGT,b As ARGT) As *ARGT
	_arg[0]=a
	_arg[1]=b
	arg=_arg
End Function

Function arg(a As ARGT, b As ARGT, c As ARGT ) As *ARGT
	memcpy(_arg,VarPtr(a),12)
	arg=_arg
End Function

Function arg(a As ARGT, b As ARGT, c As ARGT, d As ARGT) As *ARGT
	memcpy(_arg,VarPtr(a),16)
	arg=_arg
End Function

Function arg(a As ARGT, b As ARGT, c As ARGT, d As ARGT,e As ARGT ) As *ARGT
	memcpy(_arg,VarPtr(a),20)
	arg=_arg
End Function

Function arg(a As ARGT,b As ARGT,c As ARGT ,d As ARGT ,e As ARGT ,f As ARGT) As *ARGT
	memcpy(_arg,VarPtr(a),24)
	arg=_arg
End Function

Function arg(a As ARGT,b As ARGT,c As ARGT ,d As ARGT ,e As ARGT ,f As ARGT,g As ARGT) As *ARGT
	memcpy(_arg,VarPtr(a),28)
	arg=_arg
End Function

Function arg(a As ARGT,b As ARGT,c As ARGT ,d As ARGT ,e As ARGT ,f As ARGT,g As ARGT,h As ARGT ) As *ARGT
	memcpy(_arg,VarPtr(a),32)
	arg=_arg
End Function

Function arg(a As ARGT,b As ARGT,c As ARGT ,d As ARGT ,e As ARGT ,f As ARGT,g As ARGT,h As ARGT ,i As ARGT) As *ARGT
	memcpy(_arg,VarPtr(a),36)
	arg=_arg
End Function

Function arg(a As ARGT,b As ARGT,c As ARGT ,d As ARGT ,e As ARGT ,f As ARGT ,g As ARGT ,h As ARGT ,i As ARGT ,j As ARGT ,k As ARGT ,l As ARGT ,m As ARGT ,n As ARGT) As *ARGT
	memcpy(_arg,VarPtr(a),60)
	arg=_arg
End Function

'printfはこちらを推奨だが、パフォーマンス対して変わらないのでセーフとする
Dim _print_buf[1024] As Byte,_print_len AS Long
Sub printf2(format AS BytePtr,arglist AS *ARGT)
	_print_len=wvsprintf(_print_buf,format,arglist)
	PrintPtr(_print_buf,_print_len)
Endsub

'------------------------------
'		Console library
'------------------------------

Function GetConsoleCursorDw() AS DWord
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	memcpy(VarPtr(GetConsoleCursor),CmdPos.dwCursorPosition,sizeof(DWord))
EndFunction

SUb GetConsoleCursor(ByRef pos AS COORD)
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	memcpy(VarPtr(pos),VarPtr(CmdPos.dwCursorPosition),sizeof(DWord))
EndSub

Sub ConsoleReturnLine()
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	CmdPos.dwCursorPosition.X=0
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	
EndSub

Sub ConsoleLocateRelative(x As Long,y AS Long)
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos) AS DWORD)
	CmdPos.dwCursorPosition.X += x
	CmdPos.dwCursorPosition.Y += y
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	
EndSub

Sub ConsoleClearCurrentLine()
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos) AS DWORD)
	CmdPos.dwCursorPosition.X = 0
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	
	print String$(CmdPos.dwSize.X," ")
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	

EndSub

Sub ConsoleReturnChar(count AS Long)
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	CmdPos.dwCursorPosition.X-=count
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	
EndSub

Enum ABRLC_COLOR
	CC_DEFAULT
	CC_BLUE		= &H01
	CC_GREEN	= &H02
	CC_RED		= &H04
End Enum

Sub SetConsoleColor(color AS ABRLC_COLOR)
	Dim attr AS Word

	if color=CC_DEFAULT Then 
		attr=CC_BLUE or CC_GREEN or CC_RED
	Else
		attr=color And &H07
	End If

	'attr = attr or &H56

	SetConsoleTextAttribute(_System_hConsoleOut,attr)
End Sub

'コンソールのウィンドウハンドルを取得
Function GetConsoleWndHandle() AS HANDLE
	dim hConsole As HWND
	SetConsoleTitle("_FIND_STRING_RGBA_CRT_") 
	Sleep(40) 
	hConsole=FindWindow(NULL, "_FIND_STRING_RGBA_CRT_")
EndFunction

'コンソールのアイコンを変更
Sub SetConsoleIcon(IconID AS DWord)
	SendMessage(GetConsoleWndHandle(),WM_SETICON,ICON_SMALL,LoadImage(GetModuleHandle(0),IconID As BytePtr,IMAGE_ICON,GetSystemMetrics(SM_CXSMICON),GetSystemMetrics(SM_CYSMICON),LR_DEFAULTCOLOR) As Long)
EndSub

Const PRINTF_BUFFER = 1024
Sub printf(lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,
	f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord )
	'Dim Buf[PRINTF_BUFFER] AS Byte,ret AS Long	
	_print_len=wsprintf(_print_buf,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	PrintPtr(_print_buf,_print_len)
EndSub

Sub PrintPtr(Text As BytePtr)(Length AS Long)
	Dim a AS Long
	if Length=0 then 
		a=lstrlen(Text)
	Else
		a=Length
	End If
	WriteFile(_System_hConsoleOut,Text,a,VarPtr(a),ByVal NULL)
	'WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),Text,Length,NULL
Endsub

Sub PauseConsole()
	Dim buf AS DWord
	WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),ex"[PRESS ANY KEY]\0",16,VarPtr(buf),ByVal NULL)
	ReadFile(GetStdHandle(STD_INPUT_HANDLE),VarPtr(buf),1,VarPtr(buf),ByVal NULL)
EndSub

Function Dump(Data As BytePtr,Size As DWORD)(VAdr As DWORD,noHeader AS BOOL) AS DWORD
	Dim Tmp[&H20] As Byte,i As Long,Adr As DWORD
	
	'SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), BACKGROUND_BLUE OR BACKGROUND_GREEN OR BACKGROUND_RED)
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), &H0070)
	if VAdr=0 Or noHeader=FALSE then PrintPtr( ex" ADDRESS  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  0123456789ABCDEF \n")
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 1 OR 2 OR 3 OR 4)
	Do
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), &H10  OR 4 OR 3 )
		printf("%08X  ",Adr+VAdr)
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 1 OR 2 OR 3 OR 4)
'		Print " ";
		For i=0 To &H0F
			if Adr+i=>Size then
				printf("-- ",0)
			Else 
				printf("%02X ",Data[Adr+i])
			EndIf
		Next i
		PrintPtr(" ")
		For i=0 To &H0F
			if Adr+i=>Size then Goto *EXIT_LOOP
			if Data[Adr+i]<&H20 or Data[Adr+i]=&HFF then 
				PrintPtr(".")
			Else
				printf("%1c",Data[Adr+i])
			EndIf
		Next i
		i=0
		Adr+=&H10
		if Adr+i=>Size then Goto *EXIT_LOOP
		PrintPtr(ex"\n")
	Loop
*EXIT_LOOP
	PrintPtr(ex"\n")
'	Print Hex$(Adr*&H10+i)+"="+Hex$(Size)
	Dump=Adr
EndFunction

Enum PRINT_HIGHLIGHT_COLOR
	PH_ERROR   = &H000C
	PH_SUCCESS = &H000A
End Enum

Sub colorPrint(color As DWord,str AS BytePtr)
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE) , color )
	PrintPtr(str)
	SetConsoleColor(CC_DEFAULT)
End Sub



'---------------
'	Device 
'---------------
Const MAXDWORD=&HFFFFFFFF
Function SetIOTimeOut(hComPortPort AS HANDLE,TimeOut AS DWord) AS Byte
	Dim ct AS COMMTIMEOUTS
	ct.ReadIntervalTimeout=100		'連続受信タイムアウト
	ct.ReadTotalTimeoutMultiplier=10
	ct.ReadTotalTimeoutConstant=TimeOut	'Constant+Multiplier*バイト数＝タイムアウト
	ct.WriteTotalTimeoutConstant=TimeOut
	ct.WriteTotalTimeoutMultiplier=10

	SetCommTimeouts(hComPortPort,VarPtr(ct))
EndFunction

'---------------
'	Math
'---------------
Function isNan(value AS double) AS Double
	Dim dw[1] AS DWord
	memcpy(dw,VarPtr(value),8)

	if (((dw[1])>>(20) And &H7FFF)=2047) And (dw[0] or (dw[1] And &H0007FFFF))>0 Then
		isNan=TRUE
	End If
End Function

Function Nan() AS Double
	Dim DWORD_H=&H7FF55577 AS DWord
'	Dim DWORD_L=&HFF005599 AS DWord
	memcpy(VarPtr(Nan)+4,VarPtr(DWORD_H),4)
'	memcpy(VarPtr(Nan)  ,VarPtr(DWORD_L),4)
End Function

/* bibun 関数の微分係数を出す
 * 	_func  : 微分したい関数へのポインタ
 *	inValue: 関数へ渡す値
 *	return = 微分係数
 */
Typedef FN_PROTO = *Function(x AS Double) AS Double
Function bibun(_func AS FN_PROTO,inValue AS Double) AS Double
	bibun = (_func(inValue + EPS) - _func(inValue)) / EPS
End Function

Function newton(x1 AS double,func AS FN_PROTO) AS double
	Dim x AS double,xp AS double,fdash AS double,  c AS Long
	x=x1
	Do
		xp=x

		fdash=bibun(func,xp)
		if fdash=0 Then fdash=EPS
		x = xp - (func(xp) / fdash)
		if Abs(x-xp) < EPS or c>ITER_LIMITTER Then ExitDo
		c++
	Loop

	newton=x
End Function

Function GetKaiLU(ByRef A AS ABMatrix,ByRef b AS ABMatrix) AS *ABMatrix
	Dim L AS *ABMatrix,U AS *ABMatrix
	Dim y AS *ABMatrix,tmp AS *ABMatrix
	Dim sigma AS DOUBLE,i as Long,k AS Long
	x=new ABMatrix(b.y,b.x)
	y=new ABMatrix(b.y,b.x)

	A.GetLU(L,U)	
	For i = 0 To y->y-1
		sigma=0
		For k=0 To i-1
			sigma+=L->Get(i,k)*y->Get(k,0)
		Next k
		y->Set((b.Get(i,0)-sigma)/L->Get(i,i),i,0)
	Next i 

	For i = y->y-1 To 0 Step -1
		sigma=0
		For k=i To y->y-1
			sigma+=U->Get(i,k)*x->Get(k,0)
		Next k
		x->Set((y->Get(i,0)-sigma)/U->Get(i,i),i,0)
	Next i

	GetKaiLU=x
	delete y	:	delete L	:	delete U
End Function


Function MulMatrix(ByRef a AS ABMatrix,ByRef b AS ABMatrix) AS *ABMatrix
	Dim ix AS Long,iy AS Long,is AS Long
	Dim sum AS double
	Dim ret AS *ABMatrix
	ret=new ABMatrix(b.y,b.x)

	For iy=0 To ret->y-1
		For ix=0 To ret->x-1
			sum=0
			For is=0 To a.x-1
				sum+=a.Get(iy,is) * b.Get(is,ix)	
			Next is
			ret->Set( sum ,iy,ix)
		Next ix
	Next iy
	MulMatrix=ret
End Function

Function InputMatrix()(Message AS BytePtr) AS *ABMatrix
	Dim in AS String
	Dim x AS Long,ox AS Long,i As Long, y AS Long,dr[20] AS *double
	if Message<>0 Then printf(ex"%s\n",Message)
	Do
		Input ">",in
		dr[y]=Str2DoubleAry(in,x)
		if dr[y]=NULL or x=0 Then Exitdo
		if i>0 And ox<>x Then Print "行列サイズが不正です。":ExitFunction
		ox=x
		i++:y++
		if y>20 then Print "行数制限です。":Exitdo
	Loop
	'サイズが0
	if y<1 or ox<1 Then 
		For i=0 To y-1
			free(dr[i])
		Next i
		ExitFunction
	EndIf

	InputMatrix=new ABMatrix(y,ox)
	For i=0 To y-1
		For x=0 To ox-1
			InputMatrix->Set(dr[i][x],i,x)
		Next x
		free(dr[i])
	Next i

	Print
End Function

Function Str2DoubleAry(str AS BytePtr,ByRef count AS Long) AS *double	debug
	Dim i aS Long,C AS Long
	
	count=0
	if str=NULL then ExitFunction
	Str2DoubleAry=calloc(sizeof(double)*lstrlen(str)+10)

	Do
		if str[i]=0 Then ExitDo
		if str[i]<>Asc(" ") Then 
			Str2DoubleAry[C]=Val(str+i)
			C++
			'Skip to next space
			Do
				i++
				if str[i]=Asc(" ") Then Exitdo
				if str[i]=0 Then exitdo
			Loop
			continue
		End If
		i++
	Loop

	if C>0 Then
		realloc(Str2DoubleAry,sizeof(double)*(C))
		count=C
	Else
		free(Str2DoubleAry)
		Str2DoubleAry=0
	EndIf
End Function

Function CountChar(str AS BytePtr,chara AS Byte) AS Long
	if str=NULL then ExitFunction
	Dim i aS Long,C AS Long
	Do
		if str[i]=chara Then C++
		if str[i]=0 Then ExitDo
		i++
	Loop
	CountChar=C
End Function

Function GetOsMajorVersion() AS Long
	Dim Ver As OSVERSIONINFO
	Ver.dwOSVersionInfoSize=sizeof(OSVERSIONINFO)
	GetVersionEx(Ver)
	GetOsMajorVersion=Ver.dwMajorVersion
End Function

Function IsWin9x() AS Long
	if GetOsMajorVersion() = 4 Then
		IsWin9x=TRUE
	Else
		IsWin9x=FALSE
	End If
End Function




'------------------------------
'		Class library
'------------------------------
Class File
Protected
	hFile As HANDLE
Public
	path AS FilePath
	Function _openFile(_Mode AS DWORD) AS BOOL
		Dim CreateMode AS Dword
		If _Mode=GENERIC_READ then
			CreateMode=OPEN_EXISTING
		Elseif  _Mode=GENERIC_WRITE then
			CreateMode=CREATE_ALWAYS
		Else
			CreateMode=OPEN_EXISTING
		EndIf

		hFile=CreateFile(path.GetPath(), _Mode, FILE_SHARE_READ or FILE_SHARE_WRITE, ByVal 0,CreateMode, FILE_ATTRIBUTE_NORMAL, 0)
		If hFile=INVALID_HANDLE_VALUE then 
			_openFile = FALSE
			hFile=0
		Else
			_openFile = TRUE
		EndIf
	EndFunction

	
	Function openFile(inPath As BytePtr,_Mode AS DWORD) AS BOOL
		path.SetPath(inPath)
		openFile=_openFile(_Mode)
	End Function
	
/*	Function openFileW(inPath As WordPtr,_Mode AS DWORD) AS BOOL
		path.SetPath(inPath)
		openFileW=_openFile(_Mode)
	End Function
*/
	Function read(dest AS BytePtr,size As DWord) AS Long
		Dim dwAB As BytePtr
		read=ReadFile(hFile,dest,size,VarPtr(dwAB),ByVal NULL) As Long
		If read=TRUE And dwAB=0 then
			read=-1 As Long	'EOF
		ElseIf read=FALSE then
			read=-2 As Long
		Else
			read=dwAB AS Long
		EndIf
	End Function

	Function readDw() AS Long
		read(VarPtr(readDw),sizeof(DWord))
	End Function

	Function write(source AS BytePtr,size As DWord) AS Long
		WriteFile(hFile,source,size,VarPtr(write),ByVal NULL)
	End Function

	Function getFilePtr() AS DWord
		getFilePtr=SetFilePointer(hFile,0,0,FILE_CURRENT)
	EndFunction

	'up to 4GB
	Sub setFilePtr(fp AS DWord)(fpHigh AS DWord)
		'SetFilePointerの第3引数 lpDistanceToMoveHighをNULLにすると下位がLong扱いになる

		SetFilePointer(hFile,fp,VarPtr(fpHigh),FILE_BEGIN)
	End Sub

	Sub addFilePtr(fp AS DWord)
		SetFilePointer(hFile,fp,0,FILE_CURRENT)
	End Sub

	Function length() AS Long
		if hFile = 0 Then length=0 : Exitfunction
		length=GetFileSize(hFile,NULL)
	EndFunction

	Function lengthEx(ByRef highDWord AS DWord) AS Long
		if hFile = 0 Then length=0 : Exitfunction
		length=GetFileSize(hFile, VarPtr(highDWord))
	EndFunction

	Function lengthQWord() AS QWord
		if hFile = 0 Then lengthQWord=0 : Exitfunction
		Dim lowDWord As DWord, highDWord AS DWord
		lowDWord=GetFileSize(hFile, VarPtr(highDWord))
		lengthQWord = lowDWord OR (highDWord As QWord)<<32
	EndFunction

	Function getHandle() AS HANDLE
		getHandle=hFile
	EndFunction

	Sub setHandle(_handle AS HANDLE)
		hFile=_handle
	End Sub
	
	Function getPath() AS BytePtr
		getPath=path.GetPath()
	EndFunction

	Sub close()
		CloseHandle(hFile)
		hFile=0
		path.Destroy()
	End Sub
End Class


'ファイルパス用クラス
Class FilePathW
Private
	pathStr AS StringClassW
	nullidx AS DWord
	separator AS Word	' \
Public

	Sub FilePathW()
		setPathSeparator(ex"\\\0")
	End Sub

	Sub setPathSeparator(newSeparator as WordPtr)
		separator=newSeparator[0]
	End Sub

	Sub setPathSeparatorChar(newSeparator as Word)
		separator=newSeparator
	End Sub

	'ファイルかフォルダかはわからないけどパスがセットされた
	Sub SetPath(path As WordPtr)
		'ダブルクォーテーションを削除しつつメモリ確保＆格納
		pathStr.set(DelDQW(path))
		nullidx=pathStr.length()
	EndSub

	Sub SetPathA(path AS BytePtr) 
		Dim pathW AS WordPtr
		pathW=Ansi2Wide(path)
		SetPath(pathW)
		free(pathW)
	End Sub

	Sub FileDlgSetupW(ofn As *OPENFILENAME,hWnd AS HWND,opt As DWord,defFileName AS WordPtr,defExt AS WordPtr,extList As WordPtr)
		'ファイルオープン構造体の初期化
		ofn->lStructSize = sizeof(OPENFILENAME)
		ofn->hwndOwner = hWnd
		ofn->lpstrFilter = extList
		ofn->nFilterIndex = 0
		ofn->nMaxFile = MAX_PATH
		ofn->Flags=opt
		ofn->lpstrDefExt=defExt
		ofn->lpstrFile = calloc(MAX_PATH*2+4)
		if defFileName<>NULL Then _
			lstrcpyW(ofn->lpstrFile,defFileName)
	End Sub

	Function SaveFileDlg(hWnd AS HWND,defFileName AS WordPtr,defExt AS WordPtr,extList As WordPtr) AS Long
		Dim ofn AS OPENFILENAME
		FileDlgSetupW(VarPtr(ofn),hWnd,OFN_OVERWRITEPROMPT,defFileName,defExt,extList)
		GetSaveFileNameW(ofn)
		SetPath(ofn.lpstrFile)
		free(ofn.lpstrFile)
	End Function

	Function OpenFileDlg(hWnd AS HWND,defFileName AS WordPtr,defExt AS WordPtr,extList As WordPtr) AS Long
		Dim ofn AS OPENFILENAME
		FileDlgSetupW(VarPtr(ofn),hWnd,OFN_OVERWRITEPROMPT,defFileName,defExt,extList)
		GetOpenFileNameW(ofn)
		
		SetPath(ofn.lpstrFile)
		free(ofn.lpstrFile)
	End Function



	'フォルダを一階層下げるなどの用途がある
	Sub PushFile(filename As WordPtr)
		if nullidx<>0 And pathStr.ptr[nullidx-1]<>separator Then
			pathStr.addChar(separator)
		End If
		pathStr.cat(filename)
	EndSub

	Sub PushDir(SubDir As WordPtr)
		PushFile(SubDir)
		pathStr.addChar(separator)
	EndSub

	'ディレクトリから出る
	Sub PopDir()
		Dim i As Long
		For i = pathStr.length()-2 To 0 Step -1
			if pathStr.ptr[i]=separator Then	ExitFor
			if pathStr.ptr[i]=GetWord(ex":\0") Then ExitSub
		Next i
		pathStr.TerminateChar(i+1)
		'Base[i+1]=0
	EndSub
	
	'拡張子削除
	Sub deleteExtension()
		Dim extPtr AS WordPtr
		extPtr=PathFindExtensionW(pathStr.ptr)

		if extPtr=NULL Then ExitSub

		extPtr[0]=0
		nullidx=extPtr-pathStr.ptr
	End Sub

	'文字列やファイル名など追加
	Sub cat(text as WordPtr)
		pathStr.cat(text)
	EndSub

	'ファイル存在チェック
	Function isExist() AS Long
		isExist=PathFileExistsW(pathStr.ptr)
	EndFunction

	Function isDir() AS Long
		if PathIsDirectoryW(pathStr.ptr) Then 
			isDir=FALSE
		Else
			isDir=TRUE
		EndIf
	EndFunction

	Function GetPathString() AS String
		GetPathString=pathStr.getString()
	EndFunction

	Function genAddedPath(additionalPath AS WordPtr) AS String
		Dim tmp AS FilePathW
		tmp.PushFile(additionalPath)
		genAddedPath=tmp.GetPathString()
	EndFunction

	Function GetPath() AS WordPtr
		GetPath=pathStr.ptr
	EndFunction

	Function GetPathA() AS BytePtr
		GetPathA=pathStr.GetAnsi()
	EndFunction

	Function GetFileName() AS WordPtr
		GetFileName=PathFindFileNameW(pathStr.ptr)
	EndFunction

	Function GetFileExt() AS WordPtr
		GetFileExt=PathFindExtensionW(pathStr.ptr)
	EndFunction

	Function GetFileDirString() AS String
		Dim tmp AS FilePathW
		tmp.setPathSeparatorChar(separator)
		tmp.SetPath(pathStr.ptr)
		tmp.PopDir()
		GetFileDirString=tmp.GetPathString()
	EndFunction

	Sub Destroy()
		pathStr.freeStr()
		nullidx=0
	EndSub

	Sub ~FilePathW()
		Destroy()
	EndSub
End Class

Const STRCLASS_SPF_BUFFER_WIDE = 1024*2
Class StringClassW
Private
	nullidx As DWord	'nullpos
	size AS DWord	'buffer size
	ptrA AS BytePtr	'string(ANSI)
Public
	ptr AS WordPtr	'string

	Function cat(text AS WordPtr) AS Long
		Dim txlen AS DWord
		txlen=lstrlenW(text)
		requestBuffer(txlen*2)
		if (nullidx+txlen)*2 >= size Then allocStr(txlen*2+size)
		memcpy(ptr+nullidx*2,text,txlen*2)
		nullidx+=txlen
		ptr[nullidx]=0
	EndFunction

	Sub insertHead(newStr AS WordPtr)
		Dim tmp AS WordPtr
		copyToNewPtr(tmp)
		set(newStr)
		cat(tmp)
	End Sub

	Sub replaceChar(old AS *Word,newc AS *Word)
		if nullidx=0 Then ExitSub
		Dim i As Long
		Do
			if ptr[i]=0 Then ExitSub
			if ptr[i]=old[0] Then ptr[i]=newc[0]
			i++
		Loop
	End Sub

	'
	Sub requestBuffer(len As Long)
		if len > size Then allocStr(len+size)
	End Sub
	Sub requestAdditionalBuffer(len As Long)
		requestBuffer(nullidx*2+len)
	End Sub

	Sub addChar(char AS Word)
		requestBuffer(nullidx+2)
		ptr[nullidx]=char
		nullidx++
		ptr[nullidx]=0
	End Sub

	Function cpy(text AS WordPtr) AS Long
		Dim txlen AS DWord
		txlen=lstrlenW(text)
		if txlen*2 > size Then allocStr(txlen*2)
		memcpy(ptr,text,txlen)
		nullidx=txlen
		ptr[nullidx]=0
	EndFunction

	Function length() AS DWord
		length=nullidx
	EndFunction

	Function cmp(text AS WordPtr) AS Long
		cmp=lstrcmpW(ptr,text)
	EndFunction
	Function cmpi(text AS WordPtr) AS Long
		cmp=lstrcmpiW(ptr,text)
	EndFunction

	Function sprintf(lpFormat As WordPtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord )
		Dim txlen AS DWord
		txlen=lstrlenW(lpFormat)
		if txlen+STRCLASS_SPF_BUFFER_WIDE+nullidx > size then allocStr(txlen*2+STRCLASS_SPF_BUFFER_WIDE+nullidx*2)
		nullidx+=wsprintfW(ptr+nullidx*2,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	EndFunction

	Sub set(text AS WordPtr)
		freeStr()
		nullidx=lstrlenW(text)
		allocStr(nullidx*2)
		memcpy(ptr,text,nullidx*2)
	EndSub

	Sub copyToNewPtr(ByRef dest As WordPtr)
		dest=calloc(nullidx*2+2)
		memcpy(dest,ptr,nullidx*2+1)
	endSub

	Sub update()
		nullidx=lstrlenW(text)
		size=nullidx*2
	EndSub

	Sub TerminateChar(pos As DWord)
		ptr[pos]=0
		nullidx=pos
	EndSub


	Sub allocStr(newSize AS DWord)
		size=newSize+5
		if ptr=0 Then 
			ptr=calloc(size)
		Else
			ptr=realloc(ptr,size)
		EndIf
	EndSub

	Sub freeStr()
		if ptr<>0 Then free(ptr):	ptr=NULL
		if ptrA	<> NULL Then free(ptrA):	ptrA=NULL
		nullidx=0
		size=0
	EndSub

	Sub slimMem()
		ptr=realloc(ptr,nullidx*2+1)
		size=nullidx*2+1
	EndSub

	Function getString() AS String
		getString=MakeStr(GetAnsi())
	EndFunction

	Function GetAnsi() AS BytePtr
		if ptrA	<> NULL Then free(ptrA)

	   ' UnicodeからShift-JISに変換
		ptrA=Wide2Ansi(ptr)
	   
		GetAnsi=ptrA
	End Function

	Sub StringClassW()
		ptr=NULL
	EndSub

	Sub ~StringClassW()
		freeStr()
	EndSub

End Class

'コマンドライン分割ライブラリ
Class CommandLine
private 
	cmdStr AS BytePtr
	count as Long
	table AS *BytePtr

	Sub freeMem()
		if cmdStr<>0 Then free(cmdStr):cmdStr=0
		if table<>0 Then free(table):table=0
		count=0
	EndSub

	Function SkipDQ(text AS BytePtr,txlen AS Long,offset AS Long) AS Long
	'	Print
		Dim i AS Long
		For i = offset To txlen
			if text[i]=Asc(ex"\q") then ExitFor	
		Next i
		SkipDQ=i-offset+1
	End Function
Public
	Sub CommandLine()(text As BytePtr)
		if text=0 Then
			ParseCommandLine(GetCommandLine())
		Else
			ParseCommandLine(text)
		EndIf
	EndSub
	Sub ~CommandLine()
		freeMem()
	EndSub

	Function GetCount() AS Long
		GetCount=count
	EndFunction

	Function GetCmd(index AS DWord) AS BytePtr
		if index>count-1 Then GetCmd="":ExitFunction
		GetCmd=table[index]
	EndFunction

	Function GetCmdString(index AS DWord) AS String
		GetCmdString=MakeStr(table[index])
	EndFunction

	'コマンドラインオプションチェック用
	Function cmpCmd(index As DWord,cmptext As BytePtr) As Byte
		if index>count Then cmpCmd=FALSE : ExitFunction
		if lstrcmpi(table[index],cmptext)=0 Then
			cmpCmd=TRUE
		Else
			cmpCmd=FALSE
		EndIf
	EndFunction

	Function ParseCommandLine(text AS BytePtr) AS Long
'		OutputDebugString(ex"called\n")
		if cmdStr<>0 Then freeMem()
		'確保
		Dim txlen AS Long
		txlen=lstrlen(text)
		cmdStr=calloc(txlen+5)
		memcpy(cmdStr,text,txlen+1)

		'スペースを数える
		Dim ExpectedCount=0 As Long
		Dim i aS Long
		For i = 0 To txlen
			if cmdStr[i]=Asc(" ") Then 
				ExpectedCount++
			EndIf
		Next i

		'スペースの分だけテーブルを確保,構築
		table=calloc(sizeof(BytePtr)*(ExpectedCount+2)+4)
		count = 0

		Dim it=0 AS Long	'table index
		For i = 0 To txlen-1
			if cmdStr[i]<>Asc(" ") and cmdStr[i]<>0 Then
				'register to table
				table[it]=cmdStr+i
				it++

				For i = i To txlen
					if cmdStr[i]=Asc(" ") Then Exitfor
					if text[i]=Asc(ex"\q") then	i+=SkipDQ(cmdStr,txlen,i+1)':Print "!"
				Next i

				'tarminate 1 opt
				cmdStr[i]=0
			EndIf 
		Next i
		count=it
		it++
		table[it]=0
	EndFunction
End Class
/*
	1.空白以外の文字発見＝有効な文字列の先頭　-＞　テーブルに保存
	2.次のスペースまでスキップ
		2.5 そのうちにダブルクォーテーション見つけたら、スキップ -> DQ内のスペースは分割されない
	3.goto 1 (ｺﾚにより、余分なスペースがいなくなる)
*/
Class CommandLineW
private 
	cmdStr AS WordPtr
	count as Long
	table AS *WordPtr

	Sub freeMem()
		if cmdStr<>0 Then free(cmdStr):cmdStr=0
		if table<>0 Then free(table):table=0
		count=0
	EndSub

	Function SkipDQ(text AS WordPtr,txlen AS Long,offset AS Long) AS Long
	'	Print
		Dim i AS Long
		For i = offset To txlen
			if text[i]=Asc(ex"\q") then ExitFor	
		Next i
		SkipDQ=i-offset+1
	End Function
Public
	Sub CommandLineW()(text As WordPtr)
		if text=0 Then
			ParseCommandLine(GetCommandLineW())
		Else
			ParseCommandLine(text)
		endif
	EndSub

	Sub ~CommandLineW()
		freeMem()
	EndSub

	Function GetCount() AS Long
		GetCount=count
	EndFunction

	Function GetCmd(index AS DWord) AS WordPtr
		if index>count-1 Then GetCmd=ex"\0":ExitFunction
		GetCmd=table[index]
	EndFunction

	Function GetCmdString(index AS DWord) AS String
		GetCmdString=MakeStr(table[index])
	EndFunction

	'コマンドラインオプションチェック用
	Function cmpCmd(index As DWord,cmptext As WordPtr) As Byte
		if index>count Then cmpCmd=FALSE : ExitFunction
		if lstrcmpiW(table[index],cmptext)=0 Then
			cmpCmd=TRUE
		Else
			cmpCmd=FALSE
		endif
	Endfunction

	Function ParseCommandLine(text AS WordPtr) AS Long
'		OutputDebugString(ex"called\n")
		if cmdStr<>0 Then freeMem()
		'確保
		Dim txlen AS Long
		txlen=lstrlenW(text)
		cmdStr=calloc(txlen*sizeof(Word)+5)
		memcpy(cmdStr,text,txlen*sizeof(Word)+1)

		'スペースを数える
		Dim ExpectedCount=0 As Long
		Dim i aS Long
		For i = 0 To txlen
			if cmdStr[i]=Asc(" ") Then 
				ExpectedCount++
			endif
		Next i

		'スペースの分だけテーブルを確保,構築
		table=calloc(sizeof(WordPtr)*(ExpectedCount+2)+4)
		count = 0

		Dim it=0 AS Long	'table index
		For i = 0 To txlen-1
			if cmdStr[i]<>Asc(" ") and cmdStr[i]<>0 Then
				'register to table
				table[it]=cmdStr+i*sizeof(Word)
				it++

				For i = i To txlen
					if cmdStr[i]=Asc(" ") Then Exitfor
					if text[i]=Asc(ex"\q") then	i+=SkipDQ(cmdStr,txlen,i+1)':Print "!"
				Next i

				'tarminate 1 opt
				cmdStr[i]=0
			endif 
		Next i
		count=it
		it++
		table[it]=0
	EndFunction
End Class



'ファイルパス用クラス
Class FilePath
Private
	pathStr AS StringClass
	pNull AS DWord
	separator AS Char	' \
Public

	Sub FilePath()
		setPathSeparator("\")
	End Sub

	Sub setPathSeparator(newSeparator as BytePtr)
		separator=newSeparator[0]
	End Sub

	Sub setPathSeparatorChar(newSeparator as Char)
		separator=newSeparator
	End Sub

	'ファイルかフォルダかはわからないけどパスがセットされた
	Sub SetPath(path As BytePtr)
		'ダブルクォーテーションを削除しつつメモリ確保＆格納
		pathStr.set(DelDQ(path))
		pNull=pathStr.length()
	EndSub

	'フォルダを一階層下げるなどの用途がある
	Sub PushFile(filename As BytePtr)
		if pNull<>0 And pathStr.ptr[pNull-1]<>separator Then
			pathStr.addChar(separator)
		End If
		pathStr.cat(filename)
	EndSub

	Sub PushDir(SubDir As BytePtr)
		PushFile(SubDir)
		pathStr.addChar(separator)
	EndSub

	'ディレクトリから出る
	Sub PopDir()
		Dim i As Long
		For i = pathStr.length()-2 To 0 Step -1
			if pathStr.ptr[i]=separator Then	ExitFor
			if pathStr.ptr[i]=Asc(":") Then ExitSub
		Next i
		pathStr.TerminateChar(i+1)
		'Base[i+1]=0
	EndSub
	
	'拡張子削除
	Sub deleteExtension()
		Dim extPtr AS BytePtr
		extPtr=PathFindExtension(pathStr.ptr)

		if extPtr=NULL Then ExitSub

		extPtr[0]=0
		pNull=extPtr-pathStr.ptr
	End Sub

	'文字列やファイル名など追加
	Sub cat(text as BytePtr)
		pathStr.cat(text)
	EndSub

	'ファイル存在チェック
	Function isExist() AS Long
		isExist=PathFileExists(pathStr.ptr)
	EndFunction

	Function isDir() AS Long
		if PathIsDirectory(pathStr.ptr) Then 
			isDir=FALSE
		Else
			isDir=TRUE
		EndIf
	EndFunction

	Function GetPathString() AS String
		GetPathString=pathStr.getString()
	EndFunction

	Function genAddedPath(additionalPath AS BytePtr) AS String
		genAddedPath=sprintfStr("%s%s",pathStr.ptr,additionalPath)
	EndFunction

	Function GetPath() AS BytePtr
		GetPath=pathStr.ptr
	EndFunction

	Function GetFileName() AS BytePtr
		GetFileName=PathFindFileName(pathStr.ptr)
	EndFunction

	Function GetFileExt() AS BytePtr
		GetFileExt=PathFindExtension(pathStr.ptr)
	EndFunction

	Function GetFileDirString() AS String
		Dim tmp AS FilePath
		tmp.setPathSeparatorChar(separator)
		tmp.SetPath(pathStr.ptr)
		tmp.PopDir()
		GetFileDirString=MakeStr(tmp.GetPath())
	EndFunction

	Sub Destroy()
		pathStr.freeStr()
		pNull=0
	EndSub

	Sub ~FilePath()
		Destroy()
	EndSub
End Class


'EasyIOのクラス版
Class Device 
	Inherits File
	
Public
	Function IoCommand(ioCommand As DWord) As BOOL
		Dim dwAB AS DWord
		if DeviceIoControl(hFile,ioCommand,NULL,0,NULL,0,VarPtr(dwAB),NULL)=0 Then _
			ExitFunction
		IoCommand=TRUE
	End Function
End Class

'速度重視の文字列クラス
Const STRCLASS_SPF_BUFFER = 1024
Class StringClass
Private
	pNull As DWord	'nullpos
	size AS DWord	'buffer size
Public
	ptr AS BytePtr	'string

	Function cat(text AS BytePtr) AS Long
		Dim txlen AS DWord
		txlen=lstrlen(text)
		if pNull+txlen >= size Then allocStr(txlen+size)
		memcpy(ptr+pNull,text,txlen)
		pNull+=txlen
		ptr[pNull]=0
	EndFunction

	Sub insertHead(newStr AS BytePtr)
		Dim tmp AS BytePtr
		copyToNewPtr(tmp)
		set(newStr)
		cat(tmp)
	End Sub

	Sub replaceChar(old AS *Byte,newc AS *Byte)
		if pNull=0 Then ExitSub
		Dim i As Long
		Do
			if ptr[i]=0 Then ExitSub
			if ptr[i]=old[0] Then ptr[i]=newc[0]
			i++
		Loop
	End Sub

	'
	Sub requestBuffer(len As Long)
		if pNull+len > size Then allocStr(len+size)
	End Sub

	Sub addChar(char AS Char)
		requestBuffer(pNull+1)
		ptr[pNull]=char
		pNull++
		ptr[pNull]=0
	End Sub

	Function cpy(text AS BytePtr) AS Long
		Dim txlen AS DWord
		txlen=lstrlen(text)
		if txlen > size Then allocStr(txlen)
		memcpy(ptr,text,txlen)
		pNull=txlen
		ptr[pNull]=0
	EndFunction

	Function length() AS DWord
		length=pNull
	EndFunction

	Function cmp(text AS BytePtr) AS Long
		cmp=lstrcmp(ptr,text)
	EndFunction
	Function cmpi(text AS BytePtr) AS Long
		cmp=lstrcmpi(ptr,text)
	EndFunction

	Function sprintf(lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord )
		Dim txlen AS DWord
		txlen=lstrlen(lpFormat)
		if txlen+STRCLASS_SPF_BUFFER+pNull > size then allocStr(txlen+STRCLASS_SPF_BUFFER+pNull)
		pNull+=wsprintf(ptr+pNull,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	EndFunction

	Sub set(text AS BytePtr)
		freeStr()
		pNull=lstrlen(text)
		allocStr(pNull)
		memcpy(ptr,text,pNull)
	EndSub

	Sub copyToNewPtr(ByRef dest As BytePtr)
		dest=calloc(pNull+2)
		memcpy(dest,ptr,pNull+1)
	endSub

	Sub update()
		pNull=lstrlen(text)
		size=pNull
	EndSub

	Sub TerminateChar(pos As DWord)
		ptr[pos]=0
		pNull=pos
	EndSub

	'あとはUnicode系とか、文字列検索とか必要になったら実装 

	Sub allocStr(newSize AS DWord)
		size=newSize+5
		if ptr=0 Then 
			ptr=calloc(size)
		Else
			ptr=realloc(ptr,size)
		EndIf
	EndSub

	Sub freeStr()
		if ptr<>0 Then free(ptr):ptr=0
		pNull=0
		size=0
	EndSub

	Sub saveMem()
		ptr=realloc(ptr,pNull+1)
		size=pNull+1
	EndSub

	Function getString() AS String
		getString=MakeStr(ptr)
	EndFunction

	Sub StringClass()
		ptr=NULL
	EndSub

	Sub ~StringClass()
		freeStr()
	EndSub

End Class

'自分のEXEファイルがあるディレクトリを扱う
Class BinalyDirectory
Private
	BinalyRoot AS BytePtr
	TempString AS BytePtr
	p AS Word
Public
	Sub BinalyDirectory()
		Dim exePath[MAX_PATH+1] AS Byte,i AS Long
		GetModuleFileName(NULL,exePath,MAX_PATH)
		For i = lstrlen(exePath) To 0 Step -1
			If exePath[i]=&H5C then ExitFor' \ だったら
		Next i
		i++
		exePath[i]=0'￥以下を潰す
		BinalyRoot=calloc(i+2)
		memcpy(BinalyRoot,exePath,i+1)
		p=(i+1) AS Word
	EndSub

	Sub ~BinalyDirectory()
		if BinalyRoot<>0 Then free(BinalyRoot)
		if TempString<>0 Then free(TempString)
	EndSub

	Function GetBinDir() AS BytePtr
		GetBinDir=BinalyRoot
	End Function

	Function MakePath(subPath AS BytePtr) AS BytePtr
		freeTmp()
		TempString=calloc(p+lstrlen(subPath)+1)
		wsprintf(TempString,"%s%s",BinalyRoot,subPath)
		MakePath=TempString
	End Function

	Function GetMadePath() AS BytePtr
		GetMadePath=TempString
	EndFunction

	Sub freeTmp()
		if TempString<>0 Then free(TempString):TempString=0
	EndSub
End Class

Class ABMatrix
Public
	x AS Long	'列数
	y AS Long 	'行数
Private
	pMatrix AS *Double
Public
	Sub ABMatrix(iny AS Long,inx AS Long)(initMatrix As *Double)
		x=inx
		y=iny
		pMatrix=malloc(sizeof(double)*inx*iny)
		if initMatrix<>NULL Then
			memcpy(pMatrix,initMatrix,sizeof(double)*inx*iny)
		Else
			FillMemory(pMatrix,sizeof(double)*inx*iny,0)
		End If
	End Sub

	Sub ~ABMatrix()
		free(pMatrix) 	:	pMatrix=NULL
	End Sub

	Sub PrintMatrix()(caption AS BytePtr)
		if caption=NULL Then caption=""
		printf(ex"%sMatrix[%08X,%d,%d] : \n",caption,pMatrix,x,y)
		Dim ix AS Long,iy AS Long
		For iy=0 To y-1
			For ix= 0 To x-1
				printfd(ex"%5.2f\t",pMatrix[ix+iy*x])
			Next ix
			Print
		Next iy
		Print ex"-------------------------------\n"
	End Sub

	Sub Overwrite(newMatrix As *Double) 	'double配列から入力
		if newMatrix<>NULL Then
			memcpy(pMatrix,newMatrix,sizeof(double)*x*y)
		End If
	End Sub

	Function Get(pos_y AS Long,pos_x AS Long) AS double
		Get=pMatrix[pos_x+pos_y*x]
	End Function

	Sub Set(value AS double,pos_y AS Long,pos_x AS Long)
		pMatrix[pos_x+pos_y*x]=value
	End Sub

	Sub MakeUnitMatrix()	'現在の行列を破棄し単位行列にする
		Dim ix AS Long,iy AS Long
		For iy=0 To y-1
			For ix= 0 To x-1
				if ix=iy Then
					pMatrix[ix+iy*x]=1
				Else
					pMatrix[ix+iy*x]=0
				End If
			Next ix
		Next iy
	End Sub

	'小行列を取得, excludeした行, 列を除去した行列を返す
	Function GetSubMatrix(excludeX AS Long,excludeY AS Long) AS *ABMatrix
		Dim ret AS *ABMatrix 
		ret=new ABMatrix(x-1,y-1)

		Dim ix AS Long,iy AS Long,nx AS Long,ny AS Long
		For iy=0 To y-1
			if iy=excludeY Then Continue
			For ix= 0 To x-1
				if ix=excludeX Then Continue
				ret->Set(pMatrix[ix+iy*x],ny,nx)
				nx++
			Next ix
			nx=0
			ny++
		Next iy
		GetSubMatrix=ret
	End Function

	'行列式detを求める
	Function determinant() AS double
		if x=<1 and y=<1 Then	determinant=pMatrix[0]:ExitFunction
		if x<>y Then ExitFunction
		Dim i AS Long,ret AS double
		Dim work AS *ABMatrix
		For i=0 To x-1
			work=GetSubMatrix(i,0)
			if i Mod 2 = 0 Then
				ret += pMatrix[i] * work->determinant()
			Else
				ret -= pMatrix[i] * work->determinant()
			End If
			delete work
		Next i
		determinant=ret
	End Function

	'行列式による逆行列取得（PDF参照）
	Function GetInverseMatrix() AS *ABMatrix
		Dim ix AS Long, iy AS Long, sign AS double
		Dim retMx As *ABMatrix, subMx AS *ABMatrix, detM AS double
		if x=<1 and y=<1 Then	GetInverseMatrix=NULL:ExitFunction

		retMx = new ABMatrix(x,y)	'戻り値の行列
		detM=determinant()
		
		For iy=0 To y-1
			For ix= 0 To x-1
				subMx=GetSubMatrix(iy,ix)	'小行列取得
				if ix Mod 2=iy Mod 2 Then	'＋−で縞々に　偶数&偶数 or 奇数＆奇数
					sign=1
				Else
					sign=-1
				End if
				retMx->Set(sign*subMx->determinant()/detM,iy,ix)	'符号 * det(小行列) / detM
				delete subMx
			Next ix
		Next iy
		GetInverseMatrix=retMx
	End Function

	'LU分解したものを取得(PDF準拠)
	Sub GetLU(ByRef LMatrix AS *ABMatrix,ByRef UMatrix AS *ABMatrix)
		Dim retL AS *ABMatrix,retU AS *ABMatrix
		Dim ix AS Long,iy AS Long,w AS Long, sigma AS double

		retL=new ABMatrix(x,y)
		retU=new ABMatrix(x,y)

		For iy=0 To y-1
			For ix= 0 To x-1
				'L
				if ix=<iy Then
					if ix=0 Then 
						retL->Set(pMatrix[iy*x],iy,0)
					Elseif ix=iy Then
						'シグマの計算
						sigma=0
						For w=0 To ix-1
							sigma+=retL->Get(iy,w) * retU->Get(w,ix)
						Next w								
						retL->Set(pMatrix[ix+iy*x]-sigma,iy,ix)
					Else
						'斜め(ix=iy以外)、先頭列(ix=0)以外の時つまりL(i,k)
						sigma=0
						For w=0 To ix-1
							sigma+=retL->Get(iy,w) * retU->Get(w,ix)
						Next w
						retL->Set(pMatrix[ix+iy*x] - sigma,iy,ix)
					End If
				End If

				'U
				if ix=>iy Then
					if ix=iy Then 
						retU->Set(1,ix,iy)	'u(i,i)=1
					Elseif iy=0 Then
						retU->Set(pMatrix[ix]/pMatrix[0],0,ix)
					Else
						'斜め以外で1行目以外の時
						sigma=0
						For w=0 To ix-1
							sigma+=retL->Get(iy,w) * retU->Get(w,ix)
						Next w
						retU->Set((pMatrix[ix+iy*x]-sigma)/retL->Get(iy,iy),iy,ix)
					End If
				End If				
			Next ix
		Next iy

		if VarPtr(LMatrix)<>NULL Then
			LMatrix=retL
		Else
			delete LMatrix
		End If
		if VarPtr(UMatrix)<>NULL Then
			UMatrix=retU
		Else
			delete UMatrix
		End If
	End Sub

	'ガウス消去法による逆行列取得
	Function GaussInverse() AS *ABMatrix
		Dim ret AS *ABMatrix,tmp AS *ABMatrix
		Dim ix AS Long,iy AS Long,sx AS Long
		Dim coff AS double

		ret=new ABMatrix(y,x)	'右側の行列　最初は単位行列
		ret->MakeUnitMatrix()
		tmp=new ABMatrix(y,x)	'左側のコピー
		tmp->Overwrite(pMatrix)

		For ix=0 To x-1
			'ターゲットを割り算で１にする
			coff=tmp->Get(ix,ix)
			if coff<>1 then
				For sx = 0 To x-1
					tmp->Set(tmp->Get(ix,sx)/coff,ix,sx)
					ret->Set(ret->Get(ix,sx)/coff,ix,sx)
				Next sx
			End If

			'ターゲット行以外のターゲット列を0にする
			For iy=0 To y-1
				if iy<>ix Then
					coff=tmp->Get(iy,ix)
					For sx = 0 To x-1
						'更新セル = 更新セル	- 消したいとこ　 × 今の列の1にしたいとこ（ix=iy） 
						tmp->Set(tmp->Get(iy,sx) - tmp->Get(ix,sx) * coff ,iy,sx)
						ret->Set(ret->Get(iy,sx) - ret->Get(ix,sx) * coff ,iy,sx)
					Next sx
				End If
			Next iy
		Next ix

		GaussInverse=ret
		delete tmp
	End Function
End Class


'------------------------------------------------------
'			たぶんもう使わない関数
'------------------------------------------------------
'#include <EasyIO.sbp>


'引数をNULLで区切る。NULL NULLで終わり (例）コマンド\0引数１\0"引数2"\0\0
Function MakeCmdLine(Text As BytePtr) as BytePtr
	Dim i AS DWORD,fDQ AS Byte,SP=-1 AS Long'-1でセット待ち
	dim dbg AS Byte
	dim  Buf As BytePtr,bi AS DWORD
	Const SPR=&H00'区切り文字NULL

	If Text=0 then ExitFunction
	Buf=calloc(lstrlen(Text)+4)
	
	For i = 0 To lstrlen(Text)
		If SP=-1 then
			If Text[i]<>&H20 then
				SP=i
				dbg=1
			Else
				Continue
			EndIf
		EndIf

		If fDQ=0 then
			If Text[i]=&H20 then
				memcpy(Buf+bi,Text+SP,i-SP)
				bi+=(i-SP)+1
				Buf[bi-1]=SPR
				SP=-1
			ElseIf Text[i]=0 then
				memcpy(Buf+bi,Text+SP,i-SP)
				bi+=(i-SP)+1
				Buf[bi-1]=SPR
			elseIf Text[i]=&H22 then'Doubleクォーテート
				fDQ=Not(fDQ)
			Else
			EndIf
			dbg=0
		Else
			If Text[i]=&H22 then'Doubleクォーテート
				fDQ=Not(fDQ)
			Else
			EndIf
		EndIf
	Next i
	Buf[bi]=0
	Buf[bi+1]=0
	MakeCmdLine=Buf
EndFunction

'↑で作られた文字列を扱う関数
'↑はNULLで区切られているので、lstrcpyみたいな関数が使える。
'この関数は指定した番号の引数をとってくる。
'EX) Text=cmd1\0cmd2\0opt1\0"path"\0\0
'2を指定すれば3つ目の「opt1」の開始アドレス0xAが返ってくる。MakeStr(Text+0xA)で「opt1」という文字列を取り出せる。
Function GetCmdAdr(Text AS BytePtr,Num As Byte) AS DWORD
	Dim i As DWORD,C As Byte
	If Num=0 then GetCmdAdr=0:ExitFunction
	Do
		If Text[i]=0 then
			If Text[i+1]=0 then GetCmdAdr=-1:ExitDo'ダブルNULL＝END
			C++
			If C=Num then GetCmdAdr=i+1:ExitDo
		EndIf
		i++
	Loop
EndFunction

Function FillString(Text As BytePtr,Buf As BytePtr,Num As DWord ,Max As DWord) As DWord
	Dim i As DWord/*,tSize As DWord*/,ti As DWord,nMake As DWord
'	tSize=lstrlen(Text)
	Do
		If i=>Max-1 OR nMake>=Num  then ExitDo
		Buf[i]=Text[ti]
		i++
		ti++
		If Text[ti]=0 then ti=0:nMake++
	Loop
	Buf[i]=0
	Buf[Max-1]=0
	FillString=i
EndFunction

'NULL文字記憶型strcat
Sub pstrcat(To As BytePtr,Src As BytePtr ,ByRef Ptr As DWORD)(Size As DWORD)
	If Size = 0 then Size=lstrlen(Src)
	memcpy(To+Ptr,Src,Size)
	'(free(Src)
	Ptr += Size
endsub

Function Lit2Big(Data As Word) As Dword
	Dim big[4] As Byte,In[3] As Byte
	memcpy(In,VarPtr(Data),2)
/*	big[0]=In[3]
	big[1]=In[2]
	big[2]=In[1]
	big[3]=In[0]*/
	big[0]=In[1]
	big[1]=In[0]
	memcpy(VarPtr(Lit2Big),big,2)
EndFunction
