'RGBA_CRT's Librarys
#include <RGBADef.sbp>
/*  Todo : 
		HTTP系をクラスに
*/

'---------------
'	Macros
'---------------
Const Abs16bit(b) = (b xor (b >> 15)) - (b >> 15) As Word

'----------------------------
'		GUI Utility
'----------------------------
Sub PumpMessage() 
	Dim msg As MSG
 	while PeekMessage( msg, NULL, 0, 0, PM_REMOVE ) 
    TranslateMessage( msg )
    DispatchMessage( msg )
  	Wend
EndSub

Function GetDlgItemHex(hWnd AS HWND) AS Long
	Dim buf as BytePtr,Length AS Long
	Length=GetWindowTextLength(hWnd)
	buf=calloc(Length+5)
	GetWindowText(hWnd,buf,Length+1)
	Dim i as Long,mode as Long
	Do
		if buf[i]=&H20 Then 
			i++
			Continue'Skip Space
		Elseif buf[i]=&H30 Then	'0'
			if buf[i+1]=&H78 Or buf[i+1]=&H58 Then	'x'
				'16進決定,0xを&Hに変更
				buf[i]=&H26:	buf[i+1]=&H48
			endif
		endif
		ExitDo		
	Loop
	GetDlgItemHex=Val(buf+i) AS Long
	free(buf)
EndFunction

Function GetDlgItemDouble(hWnd AS HWND) AS Double
	Dim buf as BytePtr,Length AS Long
	Length=GetWindowTextLength(hWnd)
	buf=calloc(Length+5)
	GetWindowText(hWnd,buf,Length+1)
	GetDlgItemDouble=Val(buf)' AS Long
	free(buf)
EndFunction

'エラーメッセージ表示
Function ErrMes(hOwner AS HWND,Text As BytePtr,Title As BytePtr,Flag As Dword) As Long
	SetForegroundWindow(hOwner)
	MessageBeep(MB_ICONHAND)
	ErrMes=MessageBox(hOwner,Text,ProgramName+" - "+MakeStr(Title),MB_ICONERROR Or Flag)
EndFunction

'printfのMessageBox版
Function MessageBoxf(hWnd AS HWND,lpCaption AS BytePtr,uType AS DWord,lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord ) AS Long
	Dim buf[1024] As Byte	'wsprintfがそもそも1024バイトしか対応してない
	wsprintf(buf,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	MessageBoxf=MessageBox(hWnd,buf,lpCaption,uType)
EndFunction

'EXEC 終了コード取得
Function RunAndGetExitCode(App As BytePtr,CmdLine As BytePtr) AS Long
	Dim si AS STARTUPINFO 
	Dim pi As PROCESS_INFORMATION
	Dim Child As HANDLE
	Dim r As DWORD

	if CreateProcess(App,CmdLine,ByVal NULL,ByVal NULL,FALSE,CREATE_NEW_CONSOLE,NULL,NULL,si,pi)=FALSE Then'CREATE_NEW_CONSOLE を 0にすれば非表示
		RunAndGetExitCode=-1
		ExitFunction
	endif

	' 子プロセス起動成功
	Child = pi.hProcess

	' 不要なスレッドハンドルをクローズする
	CloseHandle(pi.hThread)

	' 子プロセスの終了待ち
	r = WaitForSingleObject(Child, INFINITE)
	if r<>WAIT_OBJECT_0 then
		'wait error!
		RunAndGetExitCode=-1
		ExitFunction
	endif

	' 子プロセスの終了コードを取得
	Dim exitCode As DWORD
	if GetExitCodeProcess(Child, exitCode)=FALSE then
		RunAndGetExitCode=-1
		ExitFunction
	endif

	if Child<>0 then CloseHandle(Child)
	RunAndGetExitCode=exitCode
Endfunction

'----------------------
'		Binaly
'----------------------
Sub ChangeEndianDW(ByRef in As DWord)
	Dim Tmp As Byte
	Dim value As *Byte
	value=VarPtr(in)
	Tmp=value[0]
	value[0]=value[3]
	value[3]=Tmp
	Tmp=value[1]
	value[1]=value[2]
	value[2]=Tmp
EndSub

Function Str2Dw(Data As BytePtr) As DWORD
	memcpy(VarPtr(Str2Dw),Data,4)
endfunction

Function Dw2Str(Data As DWORD) As String
	Dim Str[4] As Byte
	memcpy(Str,VarPtr(Data),4)
	Str[4]=0
	Dw2Str=MakeStr(Str)
EndFunction

'InStrのバイナリ版
Function InByteBin(Data As BytePtr,Size As DWORD,Bytes As Byte)(Jump AS Long) As Long
	Dim i As DWORD,tmp As Byte
	if Jump<>0 then i=Jump
	Do
		if Data[i]=Bytes Then InByteBin=i: ExitDo
		i++
		if i => Size then InByteBin=-1: ExitDo
	Loop
EndFunction

'---------------
'	Strings
'--------------

'BM法文字列サーチ（指定文字列内に特定の文字列があるか？＝True or false）(バグあり)
Function SerchTextLine(Src As BytePtr,Text As BytePtr,sLen As DWORD,isFirst As DWORD) As Byte
	Dim Skip[255] As DWORD
	Dim tLen As DWORD'(,sLen As DWORD
	Dim i As DWORD,j As Long,k As Long
	Dim letSkip As Byte, letLast As Byte
	Dim SP AS Long
	tLen=lstrlen(Text)
	if tLen=0 then 	SerchTextLine=FALSE:	ExitFunction
	For i=0 To 255 : Skip[i]=tLen :	Next i
	For i=0 To tLen-1 
		Skip[Text[i]]=tLen-1-i 
		if Skip[Text[i]]=0 then Skip[Text[i]]=1
	Next i
	tLen--
	letLast=Text[tLen]
	For i=tLen To sLen Step Skip[letSkip]
		letSkip=Src[i]
		if letSkip=letLast Then 
			j=i-1
			k=tLen-1
			While Src[j]=Text[k]
				if k=0 then 
					Goto *FOUND
				Endif
				j--
				k--
			Wend
		Endif
	Next i
	SerchTextLine=FALSE
	ExitFunction
*FOUND
	Dim Line As BytePtr
	Dim EP As Long
	SerchTextLine=TRUE
*RETRY
	if Src[j-SP]= &H0A Or Src[j-SP]=&H0D Then if isFirst<>0 then SP--: Goto *RETRY
	EP=InStrByte(Src+j,&H0D,sLen)'+j
	if EP=0 then EP=sLen
	if EP-SP<=1 then ExitFunction
EndFunction

'この関数は作り直したほうがいい
Function InStrByte(Data As BytePtr,Serch As Byte,DataSize As DWORD) As Long
	Dim i as DWORD,si As Dword, sLen As Long
	Do
		if Data[i]=Serch then	InStrByte=i	: ExitDo
		if i=DataSize then
			InStrByte=-1
			ExitFunction
		endif
		i++
	Loop
endfunction

'APIを使った高速バージョンのダブルクォーテーション抜き
Function DelDQ(Text As BytePtr) As BytePtr
	Dim tmp[MAX_PATH] AS Byte
	lstrcpy(tmp,Text)
	PathRemoveBlanks(tmp)
	PathUnquoteSpaces(tmp)

	Dim txlen AS DWord
	txlen=lstrlen(tmp)
	DelDQ=calloc(txlen+2)
	memcpy(DelDQ,tmp,txlen+1)
EndFunction

'LF,CR -> CRLF     戻り値は別メモリなので各自開放すること
Function ConvCRLF(Text As *Byte) As BytePtr
	Dim ti As Long
	dim ci as long
	Dim l as Long
	Dim lp as Long
	Dim CRLFD As *Byte

	ti=0
	ci=0

	l= lstrlen(Text)
	CRLFD=calloc2(l+5)

	Do
		if Text[ti] = &H0A then				'0A(LF)が発見され、
			if Text[ti-1] <> &H0D then		'0D(CR)その後ろがCR以外の場合
				CRLFD[ci]=&H0D				'CRを追加
				ci++
				l++
				lp++
				CRLFD=realloc2(CRLFD,l+lp*2)	'増えた分のメモリ確保
				CRLFD[ci]=&H0A				'そしてLFを追加
			Else
				CRLFD[ci]=&H0A				'違ったら（正しくCRLFになってたら）そのまま
			Endif
		Elseif Text[ti] = &H0D then			'↑と大体同じ
			if Text[ti+1] <> &H0A then
				CRLFD[ci]=&H0D
				ci++
				l++
				lp++
				CRLFD=realloc2(CRLFD,l+lp*2)
				CRLFD[ci]=&H0A
			Else
				CRLFD[ci]=&H0D
			Endif
		Else
			CRLFD[ci]=Text[ti]				'改行文字と無関係の場合
		Endif 
		ti++
		ci++
		if ti = l Then ExitDo		
	Loop

	'メモリを確保し、戻り値をセット
	ConvCRLF=calloc2(lstrlen(CRLFD)<<1)
	lstrcpy(ConvCRLF,CRLFD)	

	'消す
	free2(CRLFD)
EndFunction

'strcmpの文字数指定バージョン
Function win_strncmpi(str1 AS BytePtr,str2 AS BytePtr,Length AS DWord) AS BOOL
	if CompareString(LOCALE_SYSTEM_DEFAULT,NORM_IGNORECASE,str1,Length,str2,Length) = CSTR_EQUAL Then
		win_strncmpi=TRUE
	Else
		win_strncmpi=FALSE
	endif
EndFunction

Function win_strncmp(str1 AS BytePtr,str2 AS BytePtr,Length AS DWord) AS BOOL
	if CompareString(LOCALE_SYSTEM_DEFAULT,0,str1,Length,str2,Length) = CSTR_EQUAL Then
		win_strncmp=TRUE
	Else
		win_strncmp=FALSE
	endif
EndFunction

'ファイルパスが正しいかチェック
Function IsFilePath(FilePath AS BytePtr) As Byte
	Dim hFile AS HANDLE,dFilePath As BytePtr
	if FilePath[0]=&H22 Then 
		dFilePath=DelDQ(FilePath)
	Else
		dFilePath=FilePath
	endif
	hFile=CreateFile(dFilePath,GENERIC_READ,FILE_SHARE_READ OR FILE_SHARE_WRITE,ByVal NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL)
	If hFile=INVALID_HANDLE_VALUE Then
		IsFilePath=FALSE
	Else
		IsFilePath=TRUE
		CloseHandle(hFile)
	EndIf
	if FilePath<>dFilePath Then free(dFilePath)
EndFunction

'------------------------------
'		Network library
'------------------------------

'URLのパーセントエンコードを解除
Function URLDecode(pFrom As BytePtr) As BytePtr
   	Dim i = 0 As DWord
	Dim ASCII As Byte
	URLDecode=calloc(MAX_PATH+5)

   Do 
		if pFrom[i]=&H25 Then '% then
			ASCII=Hex2Dec(Chr$(pFrom[i+1])+Chr$(pFrom[i+2])) AS Byte
			lstrcat(URLDecode , Chr$(ASCII))
			i=i+2
		Else
			lstrcat(URLDecode , Chr$(pFrom[i]))
		Endif
		i++			
		if pFrom[i] = 0 Then ExitDo
   Loop
End Function

'軽量化のため、移動
'Function GetHttpStatusText(HttpStatusNo As Long)

'-------------------------
'  Dynamic DLL Loader
'-------------------------
Type DLL_FUNCTION_CELL
	'関数ポインタを格納するための変数へのポインタ
	ptr AS VoidPtr
	'DLLから探す関数名
	alias AS BytePtr
EndType

'TST_DecoderDllLoaderへ改名、Decodersフォルダ内にデコーダを格納するように変更。↓の関数はRGBALibに移動
Function DynamicDllLoader(DllName AS BytePtr,func_list AS *DLL_FUNCTION_CELL,count AS Long)(opt_text AS BytePtr) As HINSTANCE
	Dim hDll AS HINSTANCE
	Dim errMes AS BytePtr

	hDll=LoadLibrary(DllName)
	if hDll=0 Then
		errMes=calloc(1024)
		if opt_text=0 Then opt_text=""
		wsprintf(errMes,ex"%s%sのロードに失敗しました。\nDLLが存在するか確認してください。\nErrorCode : %d",DllName,opt_text,GetLastError())
		Goto *DDL_RETURN_ERROR
	endif

	Dim i AS Long
	For i = 0 To count-1
		if func_list[i].ptr=0 or func_list[i].alias=0 Then Goto *DDL_RETURN_ERROR
		SetDWord(func_list[i].ptr,GetProcAddress(hDll,func_list[i].alias))	'Func_List.ptrの先に関数ポインタを格納
		if GetDWord(func_list[i].ptr)=NULL Then
			errMes=calloc(1024)
			if opt_text=0 Then opt_text=""
			wsprintf(errMes,ex"%sから必要な関数が見つかりませんでした。\n正しいバージョンのDLLか確認してください。\nProcName : %s\nErrorCode : %d",DllName,func_list[i].alias,GetLastError())
			Goto *DDL_RETURN_ERROR
		Endif
	Next i

	DynamicDllLoader=hDll
	ExitFunction
*DDL_RETURN_ERROR
	DynamicDllLoader=0
	if hDll<>0 Then FreeLibrary(hDll)
	if errMes<>0 Then 
		TST_ErrMes(errMes,STR_ERR_DLL_LOAD_TITLE,0)
		free(errMes)
	endif
EndFunction

'------------------------------
'		Console library
'------------------------------

Function GetConsoleCursorDw() AS DWord
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	memcpy(VarPtr(GetConsoleCursor),CmdPos.dwCursorPosition,sizeof(DWord))
EndFunction

SUb GetConsoleCursor(ByRef pos AS COORD)
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	memcpy(VarPtr(pos),VarPtr(CmdPos.dwCursorPosition),sizeof(DWord))
EndSub

Sub ConsoleReturnLine()
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	CmdPos.dwCursorPosition.X=0
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	
EndSub

Sub ConsoleReturnChar(count AS Long)
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	CmdPos.dwCursorPosition.X-=count
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	
EndSub

'コンソールのウィンドウハンドルを取得
Function GetConsoleWndHandle() AS HANDLE
	dim hConsole As HWND
	SetConsoleTitle("_FIND_STRING_RGBA_CRT_") 
	Sleep(40) 
	hConsole=FindWindow(NULL, "_FIND_STRING_RGBA_CRT_")
EndFunction

'コンソールのアイコンを変更
Sub SetConsoleIcon(IconID AS DWord)
	SendMessage(GetConsoleWndHandle(),WM_SETICON,ICON_SMALL,LoadImage(GetModuleHandle(0),IconID As BytePtr,IMAGE_ICON,GetSystemMetrics(SM_CXSMICON),GetSystemMetrics(SM_CYSMICON),LR_DEFAULTCOLOR) As Long)
EndSub

Const PRINTF_BUFFER = 1025
Sub printf(lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord )
	Dim Buf[PRINTF_BUFFER] AS Byte,ret AS Long,Ptr[13] AS DWord
	ret=wsprintf(Buf,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	PrintPtr(Buf,ret)
EndSub

Sub PrintPtr(Text As BytePtr)(Length AS Long)
	Dim a AS Long
	if Length=0 then Length=lstrlen(Text)
	WriteFile(_System_hConsoleOut,Text,Length,VarPtr(Length),ByVal NULL)
	'WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),Text,Length,NULL
Endsub

Sub PauseConsole()
	Dim buf AS DWord
	WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),ex"[PRESS ANY KEY]\0",16,VarPtr(buf),ByVal NULL)
	ReadFile(GetStdHandle(STD_INPUT_HANDLE),VarPtr(buf),1,VarPtr(buf),ByVal NULL)
EndSub

Function Dump(Data As BytePtr,Size As DWORD)(VAdr As DWORD,ShowHeader AS BOOL) AS DWORD
	Dim Tmp[&H20] As Byte,i As Long,Adr As DWORD
	
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), BACKGROUND_BLUE OR BACKGROUND_GREEN OR BACKGROUND_RED)
	if VAdr=0 Or ShowHeader=TRUE then Print " ADDRESS  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  0123456789ABCDEF "
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 1 OR 2 OR 3 OR 4)
	Do
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), BACKGROUND_BLUE  OR 4 OR 3 )
		wsprintf(Tmp,"%08X ",Adr+VAdr)
		Print MakeStr(Tmp);
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 1 OR 2 OR 3 OR 4)
		Print " ";
		For i=0 To &H0F
			if Adr+i=>Size then
				wsprintf(Tmp,"-- ",0)
			Else 
				wsprintf(Tmp,"%02X ",Data[Adr+i])
			endif
			Print MakeStr(Tmp);
		Next i
		Print " ";
		For i=0 To &H0F
			if Adr+i=>Size then Goto *EXIT_LOOP
			if Data[Adr+i]<&H20 then 
				Print ".";
			Else
				Print Chr$(Data[Adr+i]);
			Endif
		Next i
		i=0
		Adr+=&H10
		if Adr+i=>Size then Goto *EXIT_LOOP
		Print
	Loop
*EXIT_LOOP
'	Print
'	Print Hex$(Adr*&H10+i)+"="+Hex$(Size)
	Dump=Adr
Endfunction


'------------------------------
'		Class library
'------------------------------

'コマンドライン分割ライブラリ
Class CommandLine
private 
	cmdStr AS BytePtr
	count as Long
	table AS *BytePtr

	Sub freeMem()
		if cmdStr<>0 Then free(cmdStr):cmdStr=0
		if table<>0 Then free(table):table=0
		count=0
	EndSub

	Function SkipDQ(text AS BytePtr,txlen AS Long,offset AS Long) AS Long
	'	Print
		Dim i AS Long
		For i = offset To txlen
			if text[i]=Asc(ex"\q") then ExitFor	
		Next i
		SkipDQ=i-offset+1
	End Function
Public
	Sub CommandLine()(text As BytePtr)
		if text=0 Then
			ParseCommandLine(GetCommandLine())
		Else
			ParseCommandLine(text)
		endif
	EndSub
	Sub ~CommandLine()
		freeMem()
	EndSub

	Function GetCount() AS Long
		GetCount=count
	EndFunction

	Function GetCmd(index AS DWord) AS BytePtr
		if index>count-1 Then GetCmd="":ExitFunction
		GetCmd=table[index]
	EndFunction

	Function GetCmdString(index AS DWord) AS String
		GetCmdString=MakeStr(table[index])
	EndFunction

	'コマンドラインオプションチェック用
	Function cmpCmd(index As DWord,cmptext As BytePtr) As Byte
		if index>count Then cmpCmd=FALSE : ExitFunction
		if lstrcmpi(table[index],cmptext)=0 Then
			cmpCmd=TRUE
		Else
			cmpCmd=FALSE
		endif
	Endfunction

	Function ParseCommandLine(text AS BytePtr) AS Long
'		OutputDebugString(ex"called\n")
		if cmdStr<>0 Then freeMem()
		'確保
		Dim txlen AS Long
		txlen=lstrlen(text)
		cmdStr=calloc(txlen+5)
		memcpy(cmdStr,text,txlen+1)

		'スペースを数える
		Dim ExpectedCount=0 As Long
		Dim i aS Long
		For i = 0 To txlen
			if cmdStr[i]=Asc(" ") Then 
				ExpectedCount++
			endif
		Next i

		'スペースの分だけテーブルを確保,構築
		table=calloc(sizeof(BytePtr)*(ExpectedCount+2)+4)
		count = 0

		Dim it=0 AS Long	'table index
		For i = 0 To txlen-1
			if cmdStr[i]<>Asc(" ") and cmdStr[i]<>0 Then
				'register to table
				table[it]=cmdStr+i
				it++

				For i = i To txlen
					if cmdStr[i]=Asc(" ") Then Exitfor
					if text[i]=Asc(ex"\q") then	i+=SkipDQ(cmdStr,txlen,i+1)':Print "!"
				Next i

				'tarminate 1 opt
				cmdStr[i]=0
			endif 
		Next i
		count=it
		it++
		table[it]=0
	EndFunction
End Class
/*
	1.空白以外の文字発見＝有効な文字列の先頭　-＞　テーブルに保存
	2.次のスペースまでスキップ
		2.5 そのうちにダブルクォーテーション見つけたら、スキップ -> DQ内のスペースは分割されない
	3.goto 1 (ｺﾚにより、余分なスペースがいなくなる)

*/

'ファイルパス用クラス
Class FilePath
Private
	pathStr AS StringClass
	pNull AS DWord
Public
	'ファイルかフォルダかはわからないけどパスがセットされた
	Sub SetPath(path As BytePtr)
		'ダブルクォーテーションを削除しつつメモリ確保＆格納
		pathStr.set(DelDQ(path))
		pNull=pathStr.length()
	EndSub

	'フォルダを一階層下げるなどの用途がある
	Sub PushDir(SubDir As BytePtr)
		if pathStr.ptr[pNull-1]=Asc("\") Then
			pathStr.cat(SubDir)
			pathStr.cat("\")
		Else
			pathStr.cat(SubDir)
			pathStr.cat("\")
		Endif
	EndSub

	Sub PopDir()
		Dim i As Long
		For i = pathStr.length()-2 To 0 Step -1
			if pathStr.ptr[i]=Asc("\") Then	ExitFor
			if pathStr.ptr[i]=Asc(":") Then ExitSub
		Next i
		pathStr.TerminateChar(i+1)
		'Base[i+1]=0
	EndSub
	
	Sub cat(text as BytePtr)
		pathStr.cat(text)
	EndSub

	Function isExist() AS Long
		isExist=PathFileExists(pathStr.ptr)
	EndFunction

	Function isDir() AS Long
		if PathIsDirectory(pathStr.ptr) Then 
			isDir=FALSE
		Else
			isDir=TRUE
		Endif
	EndFunction

	Function GetPathString() AS String
		GetPathString=pathStr.getString()
	EndFunction

	Function GetPath() AS BytePtr
		GetPath=pathStr.ptr
	EndFunction

	Function GetFileName() AS BytePtr
		GetFileName=PathFindFileName(pathStr.ptr)
	EndFunction

	Function GetFileExt() AS BytePtr
		GetFileExt=PathFindExtension(pathStr.ptr)
	EndFunction

	Function GetFileDirString() AS String
		Dim tmp AS BytePtr
		pathStr.copyToNewPtr(tmp)
		PathRemoveFileSpec(tmp)
		GetFileDirString=MakeStr(tmp)
		free(tmp)
	EndFunction

	Sub Destroy()
		pathStr.freeStr()
		pNull=0
	EndSub

	Sub ~FilePath()
		Destroy()
	EndSub
End Class


'EasyIOのクラス版
Class File
Private
	hFile As HANDLE
	path AS FilePath
Public
	Function openFile(inPath As BytePtr,_Mode AS DWORD) AS Long
		Dim CreateMode AS Dword
		If _Mode=GENERIC_READ then
			CreateMode=OPEN_EXISTING
		Elseif  _Mode=GENERIC_WRITE then
			CreateMode=CREATE_ALWAYS
	    Else
	    	CreateMode=OPEN_ALWAYS
		EndIf

		hFile=CreateFile(inPath, _Mode, FILE_SHARE_READ, ByVal 0,CreateMode, FILE_ATTRIBUTE_NORMAL, 0)
		If hFile=INVALID_HANDLE_VALUE then 
			openFile = FALSE
			hFile=0
		Else
			openFile = TRUE
		Endif
		path.SetPath(inPath)
	EndFunction

	Function read(dest AS BytePtr,size As DWord) AS Long
	     Dim dwAB As BytePtr
	     read=ReadFile(hFile,dest,size,VarPtr(dwAB),ByVal NULL) As Long
	     If read=TRUE And dwAB=0 then
	          read=-1 As Long
	     ElseIf read=FALSE then
	          read=-2 As Long
	     Else
	          read=dwAB AS Long
	     EndIf
	End Function

	Function readDw() AS Long
		read(VarPtr(readDw),sizeof(DWord))
	End Function

	Function write(source AS BytePtr,size As DWord) AS Long
		WriteFile(hFile,source,size,VarPtr(write),ByVal NULL)
	End Function

	Function getFilePtr() AS DWord
		getFilePtr=SetFilePointer(hFile,0,0,FILE_CURRENT)
	EndFunction

	Sub setFilePtr(fp AS DWord)
		SetFilePointer(hFile,fp,0,FILE_BEGIN)
	End Sub

	Sub addFilePtr(fp AS DWord)
		SetFilePointer(hFile,fp,0,FILE_CURRENT)
	End Sub

	Function length() AS Long
		if hFile = 0 Then length=-1 : Exitfunction
		length=GetFileSize(hFile,NULL)
	EndFunction

	Function getHandle() AS HANDLE
		getHandle=hFile
	EndFunction

	Function getPath() AS BytePtr
		getPath=path.GetPath()
	EndFunction

	Sub close()
		CloseHandle(hFile)
		hFile=0
		path.Destroy()
	End Sub
End Class


'速度重視の文字列クラス
Const STRCLASS_SPF_BUFFER = 1024
Class StringClass
Private
	pNull As DWord
	size AS DWord
Public
	ptr AS BytePtr

	Function cat(text AS BytePtr) AS Long
		Dim txlen AS DWord
		txlen=lstrlen(text)
		if pNull+txlen >= size Then allocStr(txlen+size)
		memcpy(ptr+pNull,text,txlen)
		pNull+=txlen
		ptr[pNull]=0
	EndFunction

	Function cpy(text AS BytePtr) AS Long
		Dim txlen AS DWord
		txlen=lstrlen(text)
		if txlen > size Then allocStr(txlen)
		memcpy(ptr,text,txlen)
		pNull=txlen
		ptr[pNull]=0
	EndFunction

	Function length() AS DWord
		length=pNull
	EndFunction

	Function cmp(text AS BytePtr) AS Long
		cmp=lstrcmp(ptr,text)
	EndFunction
	Function cmpi(text AS BytePtr) AS Long
		cmp=lstrcmp(ptr,text)
	EndFunction

	Function sprintf(lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord )
		Dim txlen AS DWord
		txlen=lstrlen(lpFormat)
		if txlen+STRCLASS_SPF_BUFFER+pNull > size then allocStr(txlen+STRCLASS_SPF_BUFFER+pNull)
		pNull+=wsprintf(ptr+pNull,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	EndFunction

	Sub set(text AS BytePtr)
		freeStr()
		ptr=text
		pNull=lstrlen(text)
		size=pNull
	EndSub

	Sub copyToNewPtr(ByRef dest As BytePtr)
		dest=calloc(pNull+2)
		memcpy(dest,ptr,pNull+1)
	endSub

	Sub update()
		pNull=lstrlen(text)
		size=pNull
	EndSub

	Sub TerminateChar(pos As DWord)
		ptr[pos]=0
		pNull=pos
	EndSub

	'あとはUnicode系とか、文字列検索とか必要になったら実装 

	Sub allocStr(newSize AS DWord)
		size=newSize+5
		if ptr=0 Then 
			ptr=malloc(size)
		Else
			ptr=realloc(ptr,size)
		Endif
	EndSub

	Sub freeStr()
		if ptr<>0 Then free(ptr):ptr=0
		pNull=0
		size=0
	EndSub

	Sub saveMem()
		ptr=realloc(ptr,pNull+1)
		size=pNull+1
	EndSub

	Function getString() AS String
		getString=MakeStr(ptr)
	EndFunction

	Sub ~StringClass()
		freeStr()
	EndSub

End Class

'自分のEXEファイルがあるディレクトリを扱う
Class BinalyDirectory
Private
	BinalyRoot AS BytePtr
	TempString AS BytePtr
	p AS Word
Public
	Sub BinalyDirectory()
		Dim exePath[MAX_PATH+1] AS Byte,i AS Long
		GetModuleFileName(NULL,exePath,MAX_PATH)
		For i = lstrlen(exePath) To 0 Step -1
			If exePath[i]=&H5C then ExitFor' \ だったら
		Next i
		i++
		exePath[i]=0'￥以下を潰す
		BinalyRoot=calloc(i+2)
		memcpy(BinalyRoot,exePath,i+1)
		p=(i+1) AS Word
	EndSub

	Sub ~BinalyDirectory()
		if BinalyRoot<>0 Then free(BinalyRoot)
		if TempString<>0 Then free(TempString)
	EndSub

	Function GetBinDir() AS BytePtr
		GetBinDir=BinalyRoot
	End Function

	Function MakePath(subPath AS BytePtr) AS BytePtr
		freeTmp()
		TempString=calloc(p+lstrlen(subPath)+1)
		wsprintf(TempString,"%s%s",BinalyRoot,subPath)
		MakePath=TempString
	End Function

	Function GetMadePath() AS BytePtr
		GetMadePath=TempString
	EndFunction

	Sub freeTmp()
		if TempString<>0 Then free(TempString):TempString=0
	EndSub
End Class

'------------------------------------------------------
'			たぶんもう使わない関数
'------------------------------------------------------
#include <EasyIO.sbp>


'引数をNULLで区切る。NULL NULLで終わり (例）コマンド\0引数１\0"引数2"\0\0
Function MakeCmdLine(Text As BytePtr) as BytePtr
	Dim i AS DWORD,fDQ AS Byte,SP=-1 AS Long'-1でセット待ち
	dim dbg AS Byte
	dim  Buf As BytePtr,bi AS DWORD
	Const SPR=&H00'区切り文字NULL

	If Text=0 then ExitFunction
	Buf=calloc(lstrlen(Text)+4)
	
	For i = 0 To lstrlen(Text)
			If SP=-1 then
				If Text[i]<>&H20 then
					SP=i
					dbg=1
				Else
					Continue
				EndIf
			EndIf

			If fDQ=0 then
				If Text[i]=&H20 then
					memcpy(Buf+bi,Text+SP,i-SP)
					bi+=(i-SP)+1
					Buf[bi-1]=SPR
					SP=-1
				ElseIf Text[i]=0 then
					memcpy(Buf+bi,Text+SP,i-SP)
					bi+=(i-SP)+1
					Buf[bi-1]=SPR
				elseIf Text[i]=&H22 then'Doubleクォーテート
					fDQ=Not(fDQ)
				Else
			EndIf
			dbg=0
		Else
			If Text[i]=&H22 then'Doubleクォーテート
				fDQ=Not(fDQ)
			Else
			EndIf
		EndIf
	Next i
	Buf[bi]=0
	Buf[bi+1]=0
	MakeCmdLine=Buf
Endfunction

'↑で作られた文字列を扱う関数
'↑はNULLで区切られているので、lstrcpyみたいな関数が使える。
'この関数は指定した番号の引数をとってくる。
'EX) Text=cmd1\0cmd2\0opt1\0"path"\0\0
'2を指定すれば3つ目の「opt1」の開始アドレス0xAが返ってくる。MakeStr(Text+0xA)で「opt1」という文字列を取り出せる。
Function GetCmdAdr(Text AS BytePtr,Num As Byte) AS DWORD
	Dim i As DWORD,C As Byte
	If Num=0 then GetCmdAdr=0:ExitFunction
	Do
		If Text[i]=0 then
			If Text[i+1]=0 then GetCmdAdr=-1:ExitDo'ダブルNULL＝END
			C++
			If C=Num then GetCmdAdr=i+1:ExitDo
		EndIf
		i++
	Loop
Endfunction

Function FillString(Text As BytePtr,Buf As BytePtr,Num As DWord ,Max As DWord) As DWord
	Dim i As DWord/*,tSize As DWord*/,ti As DWord,nMake As DWord
'	tSize=lstrlen(Text)
	Do
		If i=>Max-1 OR nMake>=Num  then ExitDo
		Buf[i]=Text[ti]
		i++
		ti++
		If Text[ti]=0 then ti=0:nMake++
	Loop
	Buf[i]=0
	Buf[Max-1]=0
	FillString=i
EndFunction

'NULL文字記憶型strcat
Sub pstrcat(To As BytePtr,Src As BytePtr ,ByRef Ptr As DWORD)(Size As DWORD)
     If Size = 0 then Size=lstrlen(Src)
     memcpy(To+Ptr,Src,Size)
	'(free(Src)
     Ptr += Size
endsub

Function Lit2Big(Data As Word) As Dword
	Dim big[4] As Byte,In[3] As Byte
	memcpy(In,VarPtr(Data),2)
/*	big[0]=In[3]
	big[1]=In[2]
	big[2]=In[1]
	big[3]=In[0]*/
	big[0]=In[1]
	big[1]=In[0]
	memcpy(VarPtr(Lit2Big),big,2)
EndFunction
