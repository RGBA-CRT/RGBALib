'RGBA_CRT's Librarys
#include "RGBADef.sbp"
#include "EasyIO.sbp"
/*  Todo : 
		HTTP系をクラスに
*/


'--------------------------------------------------------
'	要求APIが環境依存（Win95デフォルトから外れるもの）
'--------------------------------------------------------

' %fが使える
Declare Function printfvc cdecl Lib "msvcrt.dll" Alias "printf" (str As BytePtr,format As BytePtr, ...) As Long
Declare Function printfvc4 cdecl Lib "msvcrt.dll" Alias "printf" (str As BytePtr,format As BytePtr, ...) As Long
Declare Function printfd cdecl Lib "msvcrt.dll" Alias "printf" (format As BytePtr, v1 As Double,...) As Long
Declare Function sprintfvc cdecl Lib "msvcrt.dll" Alias "sprintf" (str As BytePtr,format As BytePtr, ...) As Long
Declare Function sprintfd cdecl Lib "msvcrt.dll" Alias "sprintf" (str As BytePtr,format As BytePtr, d1 As double,...) As Long


'---------------
'	Macros
'---------------
Const Abs16bit(b) = (b xor (b >> 15)) - (b >> 15) As Word
Const ChangeEndianWord(x) = ((x>>8) and &HFF) or (x and &HFF)<<8

'----------------------------
'		GUI Utility
'----------------------------
Sub PumpMessage() 
	Dim msg As MSG
 	while PeekMessage( msg, NULL, 0, 0, PM_REMOVE ) 
	TranslateMessage( msg )
	DispatchMessage( msg )
  	Wend
EndSub

Function GetDlgItemHex(hWnd As HWND) As Long
	Dim buf As BytePtr,Length As Long
	Length=GetWindowTextLength(hWnd)
	buf=calloc(Length+5)
	GetWindowText(hWnd,buf,Length+1)
	Dim i As Long,mode As Long
	Do
		if buf[i]=&H20 Then 
			i++
			Continue'Skip Space
		Elseif buf[i]=&H30 Then	'0'
			if buf[i+1]=&H78 Or buf[i+1]=&H58 Then	'x'
				'16進決定,0xを&Hに変更
				buf[i]=&H26:	buf[i+1]=&H48
			EndIf
		EndIf
		ExitDo		
	Loop
	GetDlgItemHex=Val(buf+i) As Long
	free(buf)
EndFunction

Function GetDlgItemDouble(hWnd As HWND) As Double
	Dim buf As BytePtr,Length As Long
	Length=GetWindowTextLength(hWnd)
	buf=calloc(Length+5)
	GetWindowText(hWnd,buf,Length+1)
	GetDlgItemDouble=Val(buf)' As Long
	free(buf)
EndFunction

'Auto Allocate
Function GetWndTextAA(hWnd As HWND) As BytePtr
	Dim buf As BytePtr,Length As Long
	Length=GetWindowTextLength(hWnd)
	GetWndTextAA=calloc(Length+5)
	GetWindowText(hWnd,GetWndTextAA,Length+1)
EndFunction
/*
'エラーメッセージ表示
Function ErrMes(hOwner As HWND,Text As BytePtr,Title As BytePtr,Flag As Dword) As Long
	SetForegroundWindow(hOwner)
	MessageBeep(MB_ICONHAND)
	ErrMes=MessageBox(hOwner,Text,ProgramName+" - "+MakeStr(Title),MB_ICONERROR Or Flag)
EndFunction*/

'エラーメッセージ表示(TST用)
Function ErrMes(hOwner As HWND,Text As BytePtr,Title As BytePtr,Flag As Dword)(ErrCode As DWord) As Long
	SetForegroundWindow(hOwner)
	MessageBeep(MB_ICONHAND)
	if ErrCode=0 Then
		ErrMes=MessageBox(hOwner,Text,sprintfStr("%s - %s",ProgramName As DWord,Title As DWord),MB_ICONERROR Or Flag)
	'	DBM(Text)
	Else
		Dim SysErrMes As BytePtr
		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER or FORMAT_MESSAGE_FROM_SYSTEM or FORMAT_MESSAGE_IGNORE_INSERTS, _
  			NULL, ErrCode, LANG_USER_DEFAULT, VarPtr(SysErrMes), 0, NULL)
		ErrMes=MessageBoxf(hOwner,ProgramName+" - "+MakeStr(Title),MB_ICONERROR Or Flag,ex"%s\nErrCode : %d\n%s",Text As DWord,ErrCode,SysErrMes As DWord)
		free(SysErrMes)
	EndIf
EndFunction

'printfのMessageBox版
Function MessageBoxf(hWnd As HWND,lpCaption As BytePtr,uType As DWord,lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord ) As Long
	Dim buf[1024] As Byte	'wsprintfがそもそも1024バイトしか対応してない
	wsprintf(buf,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	MessageBoxf=MessageBox(hWnd,buf,lpCaption,uType)
EndFunction

'EXEC 終了コード取得
Function RunAndGetExitCode(App As BytePtr,CmdLine As BytePtr) As Long
	Dim si As STARTUPINFO 
	Dim pi As PROCESS_INFORMATION
	Dim Child As HANDLE
	Dim r As DWORD

	if CreateProcess(App,CmdLine,ByVal NULL,ByVal NULL,FALSE,CREATE_NEW_CONSOLE,NULL,NULL,si,pi)=FALSE Then'CREATE_NEW_CONSOLE を 0にすれば非表示
		RunAndGetExitCode=-1
		ExitFunction
	EndIf

	' 子プロセス起動成功
	Child = pi.hProcess

	' 不要なスレッドハンドルをクローズする
	CloseHandle(pi.hThread)

	' 子プロセスの終了待ち
	r = WaitForSingleObject(Child, INFINITE)
	if r<>WAIT_OBJECT_0 then
		'wait error!
		RunAndGetExitCode=-1
		ExitFunction
	EndIf

	' 子プロセスの終了コードを取得
	Dim exitCode As DWORD
	if GetExitCodeProcess(Child, exitCode)=FALSE then
		RunAndGetExitCode=-1
		ExitFunction
	EndIf

	if Child<>0 then CloseHandle(Child)
	RunAndGetExitCode=exitCode
EndFunction

' requires InitCommonControls()
Function CreateTooltip(hOwner As HWND, hTooltip As *HANDLE, stTool As *TOOLINFO, text As BytePtr) As BOOL
	SetDWord(hTooltip,_
		CreateWindowEx( 0 , TOOLTIPS_CLASS ,_
			NULL , TTS_ALWAYSTIP ,_
			CW_USEDEFAULT , CW_USEDEFAULT ,_
			CW_USEDEFAULT , CW_USEDEFAULT ,_
			hOwner , NULL , GetModuleHandle(0) ,_
			NULL 
		)
	)

	GetClientRect(hOwner , ByVal VarPtr(stTool->rect))
		
	stTool->cbSize = sizeof(TOOLINFO)
	stTool->uFlags = TTF_SUBCLASS
	stTool->hwnd = hOwner
	stTool->lpszText = text

	CreateTooltip = SendMessage(GetDWord(hTooltip) As HWND, TTM_ADDTOOL , 0 , stTool As Long)

End Function


Function GetCheckBox(Ctrl As HWND) As BOOL
	If SendMessage(Ctrl,BM_GETCHECK,0,0) = BST_CHECKED then
		GetCheckBox=TRUE
	Else
		GetCheckBox=FALSE
	End If
End Function

Function SetCheckBox(Ctrl As HWND,bValue As BOOL) As Byte
	SendMessage(Ctrl,BM_SETCHECK,bValue,bValue)
End Function

Sub SetWindowTextFormat(hWnd AS HANDLE, lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord ) 
	Dim dbuf[1024] As Byte
	Dim p AS DWord
	p=wsprintf(dbuf,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)

	SetWindowText(hWnd, dbuf)
EndSub


'----------------------
'		Binaly
'----------------------

Function isSameBin(dat1 As BytePtr, dat2 As BytePtr,length As DWord) As BOOL
	Dim i  As DWord
	For i = 0 To length-1
		if dat1[i]<>dat2[i] Then
			isSameBin=FALSE
			ExitFunction
		EndIf
	Next i
	isSameBin=TRUE
End Function

Sub ChangeEndianDW(ByRef in As DWord)
	Dim Tmp As Byte
	Dim value As *Byte
	value=VarPtr(in)
	Tmp=value[0]
	value[0]=value[3]
	value[3]=Tmp
	Tmp=value[1]
	value[1]=value[2]
	value[2]=Tmp
EndSub

Function ChangeEndianDW2(in As DWord) As DWord
	Dim Tmp As Byte
	Dim value As *Byte
	value=VarPtr(in)
	Tmp=value[0]
	value[0]=value[3]
	value[3]=Tmp
	Tmp=value[1]
	value[1]=value[2]
	value[2]=Tmp
	ChangeEndianDW2=GetDWord(value)
EndFunction

Function Str2Dw(Data As BytePtr) As DWORD
	Str2Dw=GetDWord(Data)
	'memcpy(VarPtr(Str2Dw),Data,4)
EndFunction

Function Dw2Str(Data As DWORD) As String
	Dim Str[4] As Byte, i As Long
	memcpy(Str,VarPtr(Data),4)
	For i = 0 To 3
		if Str[i] < &H20 Then Str[i]=&H20
	Next i
	Str[4]=0
	Dw2Str=MakeStr(Str)
EndFunction

'InStrのバイナリ版
Function InByteBin(Data As BytePtr,Size As DWORD,Bytes As Byte)(Jump As Long) As Long
	Dim i As DWORD,tmp As Byte
	if Jump<>0 then i=Jump
	Do
		if Data[i]=Bytes Then InByteBin=i: ExitDo
		i++
		if i => Size then InByteBin=-1: ExitDo
	Loop
EndFunction

Function SwapWord(val As Word) As Word
	SwapWord = ((val<<8) And &HFF00) Or ((val>>8) And &H00FF) 
End Function

Function ReverseDWord(val As DWord) As DWord
	'ABCD
	'D  D	; << 3
	' CC	; << 1
	' BB	; >> 1
	'A  A	; >>3
	ReverseDWord = ((val<<24) And &HFF000000) Or ((val<<8) And &H00FF0000)  Or ((val>>8) And &H0000FF00) Or ((val>>24) And &H000000FF) 
EndFunction


'---------------
'	Strings
'--------------


Function Wide2Ansi(utf16 As WordPtr) As BytePtr
'Function UTF16ToSJIS(utf16 As WordPtr) As BytePtr
	Dim l As DWord
   ' UnicodeからShift-JISに変換
   l=WideCharToMultiByte(CP_ACP, 0, utf16, -1, 0, 0, 0, 0)
   Wide2Ansi=calloc(l)
   WideCharToMultiByte(CP_ACP, 0, utf16, -1, Wide2Ansi, l, 0, 0)
End Function

Function Wide2AnsiEx(wideStr As WordPtr, ansiStr As BytePtr, ansiLen As Long) As DWord
	Dim l As DWord
	' Todo: Impl Local Buffer
  	' UnicodeからShift-JISに変換(勝手にmallocしない版）
  	l=WideCharToMultiByte(CP_ACP, 0, wideStr, -1, 0, 0, 0, 0)
	if ansiLen <= l then l = ansiLen
	Wide2AnsiEx = WideCharToMultiByte(CP_ACP, 0, wideStr, -1, ansiStr, l, 0, 0)
End Function

Function Ansi2Wide(ansi As BytePtr) As WordPtr
	Dim l As Long
	l=MultiByteToWideChar(CP_ACP, 0, ansi, -1, NULL, 0)
	Ansi2Wide=calloc(l*2+4)
	MultiByteToWideChar(CP_ACP, 0, ansi, -1, Ansi2Wide, l)
End Function

Function Ansi2Wide_AutoAlloc(ansi As BytePtr, wide As *WordPtr) As Long
	Dim l As Long, pwide As WordPtr
	l=MultiByteToWideChar(CP_ACP, 0, ansi, -1, NULL, 0)
	pwide = malloc(l*2+2)
	Ansi2Wide_AutoAlloc = MultiByteToWideChar(CP_ACP, 0, ansi, -1, pwide, l)
	SetDWord(wide, pwide)
End Function

' Note: CP_UTF8 is supported Windows 98/Me, Windows NT 4.0 and later
Function UTF8ToUnicode(utf8Str As BytePtr) As BytePtr
	Dim l As Long
	l=MultiByteToWideChar(CP_UTF8, 0, utf8Str As WordPtr, -1, NULL, 0)
	UTF8ToUnicode=calloc(l*3)
	MultiByteToWideChar(CP_UTF8, 0, utf8Str, -1, UTF8ToUnicode, l)
End Function

' Note: CP_UTF8 is supported Windows 98/Me, Windows NT 4.0 and later
Function UTF8ToSJIS(utf8Str As BytePtr) As BytePtr
	Dim l As Long,uni As WordPtr
	l=MultiByteToWideChar(CP_UTF8, 0, utf8Str, -1, NULL, 0)
	if l=0 then
		UTF8ToSJIS=calloc(64)
		wsprintf(UTF8ToSJIS, "[Error] UTF8ToSJIS fail. GLE=%d", GetLastError())
		ExitFunction
	End If
	uni=calloc(l*3)
	UTF8ToSJIS=calloc(l*3)
	MultiByteToWideChar(CP_UTF8, 0, utf8Str, -1, uni, l)
	WideCharToMultiByte(CP_ACP,0,uni,-1,UTF8ToSJIS,l*3,0,0)
	free(uni)
End Function

' Note: CP_UTF8 is supported Windows 98/Me, Windows NT 4.0 and later
Function UTF8toSJIS_Str(source As BytePtr) As String
   Dim u2s As BytePtr
   Dim u2s_out As BytePtr
   Dim l As Long
   
   ' UTF-8からUnicodeに変換
   l=MultiByteToWideChar(CP_UTF8, 0, source, -1, 0, 0)
   u2s_out=calloc(l*2+2)
   MultiByteToWideChar(CP_UTF8, 0, source, -1, u2s_out, l)
   
   ' UnicodeからShift-JISに変換
   l=WideCharToMultiByte(CP_ACP, 0, u2s_out, -1, 0, 0, 0, 0)
   UTF8toSJIS_Str=ZeroString(l)
   WideCharToMultiByte(CP_ACP, 0, u2s_out, -1, UTF8toSJIS_Str, l, 0, 0)
   
   ' 後始末
   free(u2s_out)
End Function


'BM法文字列サーチ（指定文字列内に特定の文字列があるか？＝True or false）(バグあり)
Function SerchTextLine(Src As BytePtr,Text As BytePtr,sLen As DWORD,isFirst As DWORD) As Byte
	Dim Skip[255] As DWORD
	Dim tLen As DWORD'(,sLen As DWORD
	Dim i As DWORD,j As Long,k As Long
	Dim letSkip As Byte, letLast As Byte
	Dim SP As Long
	tLen=lstrlen(Text)
	if tLen=0 then 	SerchTextLine=FALSE:	ExitFunction
	For i=0 To 255 : Skip[i]=tLen :	Next i
	For i=0 To tLen-1 
		Skip[Text[i]]=tLen-1-i 
		if Skip[Text[i]]=0 then Skip[Text[i]]=1
	Next i
	tLen--
	letLast=Text[tLen]
	For i=tLen To sLen Step Skip[letSkip]
		letSkip=Src[i]
		if letSkip=letLast Then 
			j=i-1
			k=tLen-1
			While Src[j]=Text[k]
				if k=0 then 
					Goto *FOUND
				EndIf
				j--
				k--
			Wend
		EndIf
	Next i
	SerchTextLine=FALSE
	ExitFunction
*FOUND
	Dim Line As BytePtr
	Dim EP As Long
	SerchTextLine=TRUE
*RETRY
	if Src[j-SP]= &H0A Or Src[j-SP]=&H0D Then if isFirst<>0 then SP--: Goto *RETRY
	EP=InStrByte(Src+j,&H0D,sLen)'+j
	if EP=0 then EP=sLen
	if EP-SP<=1 then ExitFunction
EndFunction

'未デバッグ
Function FindStr(text As BytePtr,size As DWord,target As BytePtr) As Long
	Dim i As Long,tarLen As Long
	tarLen=lstrlen(target)

	' [最適化]4バイト以上ある場合はCompareガードをDWordで比較する
	if tarLen > 4 Then
		Do
			if GetDWord(text+i)=GetDWord(target) Then
				if CompareString(LOCALE_SYSTEM_DEFAULT,0,text+i,tarLen,target,tarLen)=CSTR_EQUAL Then
					ExitDo
				Else
					i+=tarLen
				End If
			Endif
			i++
			If text[i]=0 Then
				FindStr=-1
				ExitFunction
			End If
			if i>size Then 
				FindStr=-2
				ExitFunction
			End If
		Loop
	Else
		Do
			if text[i]=target[0] Then
				if CompareString(LOCALE_SYSTEM_DEFAULT,0,text+i,tarLen,target,tarLen)=CSTR_EQUAL Then
					ExitDo
				Else
					i+=tarLen
				End If
			Endif
			i++
			If text[i]=0 Then
				FindStr=-1
				ExitFunction
			End If
			if i>size Then 
				FindStr=-2
				ExitFunction
			End If
		Loop
	Endif
	FindStr=i
End Function

'この関数は作り直したほうがいい
Function InStrByte(Data As BytePtr,Serch As Byte,DataSize As DWORD) As Long
	Dim i As DWORD,si As Dword, sLen As Long
	Do
		if Data[i]=Serch then	InStrByte=i	: ExitDo
		if i=DataSize then
			InStrByte=-1
			ExitFunction
		EndIf
		i++
	Loop
EndFunction

'APIを使った高速バージョンのダブルクォーテーション抜き
Function DelDQ(Text As BytePtr) As BytePtr
	Dim tmp[MAX_PATH] As Byte
	lstrcpy(tmp,Text)
	PathRemoveBlanks(tmp)
	PathUnquoteSpaces(tmp)

	Dim txlen As DWord
	txlen=lstrlen(tmp)
	DelDQ=calloc(txlen+2)
	memcpy(DelDQ,tmp,txlen+1)
EndFunction

Function DelDQW(Text As WordPtr) As WordPtr
	Dim tmp[MAX_PATH] As Word
	debug
	PrintPtr(ex"lstrcpy\n")
	wcscpy(tmp,Text)
	PrintPtr(ex"blank\n")
	PathRemoveBlanksW(tmp)
	PrintPtr(ex"unq\n")
	PathUnquoteSpacesW(tmp)
		Dump(tmp, 4096)

	Dim txlen As DWord
	txlen=lstrlenW(tmp)
	DelDQW=calloc(txlen*2+4)
	memcpy(DelDQW,tmp,txlen*2+2)
EndFunction

' DelDqExW, Win95+IE4 required
Function NormalizePathW_AutoAlloc(Text As WordPtr, newTextBuffer As *WordPtr) As Long
	Dim tmp As WordPtr
	Dim txlen As DWord

	'copy text
	txlen = lstrlenW(Text)
	tmp   = malloc(txlen*2+2)
	memcpy(tmp,Text,txlen*2+2) '+2 = null cahr

	' normalize
	PathRemoveBlanksW(tmp)
	PathUnquoteSpacesW(tmp)

	SetDWord(newTextBuffer, tmp)
	NormalizePathW_AutoAlloc = txlen
EndFunction

'LF,CR -> CRLF	戻り値は別メモリなので各自開放すること
Function ConvCRLF(Text As *Byte) As BytePtr
	Dim ti As Long
	dim ci As long
	Dim l As Long
	Dim lp As Long
	Dim CRLFD As *Byte

	ti=0
	ci=0

	l= lstrlen(Text)
	CRLFD=calloc2(l+5)

	Do
		if Text[ti] = &H0A then				'0A(LF)が発見され、
			if Text[ti-1] <> &H0D then		'0D(CR)その後ろがCR以外の場合
				CRLFD[ci]=&H0D				'CRを追加
				ci++
				l++
				lp++
				CRLFD=realloc2(CRLFD,l+lp*2)	'増えた分のメモリ確保
				CRLFD[ci]=&H0A				'そしてLFを追加
			Else
				CRLFD[ci]=&H0A				'違ったら（正しくCRLFになってたら）そのまま
			EndIf
		Elseif Text[ti] = &H0D then			'↑と大体同じ
			if Text[ti+1] <> &H0A then
				CRLFD[ci]=&H0D
				ci++
				l++
				lp++
				CRLFD=realloc2(CRLFD,l+lp*2)
				CRLFD[ci]=&H0A
			Else
				CRLFD[ci]=&H0D
			EndIf
		Else
			CRLFD[ci]=Text[ti]				'改行文字と無関係の場合
		EndIf 
		ti++
		ci++
		if ti = l Then ExitDo		
	Loop

	'メモリを確保し、戻り値をセット
	ConvCRLF=calloc2(lstrlen(CRLFD)<<1)
	lstrcpy(ConvCRLF,CRLFD)	

	'消す
	free2(CRLFD)
EndFunction

'strcmpの文字数指定バージョン
Function win_strncmpi(str1 As BytePtr,str2 As BytePtr,Length As DWord) As BOOL
	if CompareString(LOCALE_SYSTEM_DEFAULT,NORM_IGNORECASE,str1,Length,str2,Length) = CSTR_EQUAL Then
		win_strncmpi=TRUE
	Else
		win_strncmpi=FALSE
	EndIf
EndFunction

Function win_strncmp(str1 As BytePtr,str2 As BytePtr,Length As DWord) As BOOL
	if CompareString(LOCALE_SYSTEM_DEFAULT,0,str1,Length,str2,Length) = CSTR_EQUAL Then
		win_strncmp=TRUE
	Else
		win_strncmp=FALSE
	EndIf
EndFunction

'ファイルパスが正しいかチェック
Function IsFilePath(FilePath As BytePtr) As BOOL
	Dim hFile As HANDLE,dFilePath As BytePtr
	if FilePath[0]=&H22 Then 
		dFilePath=DelDQ(FilePath)
	Else
		dFilePath=FilePath
	EndIf
	hFile=CreateFile(dFilePath,GENERIC_READ,FILE_SHARE_READ OR FILE_SHARE_WRITE,ByVal NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL)
	If hFile=INVALID_HANDLE_VALUE Then
		IsFilePath=FALSE
	Else
		IsFilePath=TRUE
		CloseHandle(hFile)
	EndIf
	if FilePath<>dFilePath Then free(dFilePath)
EndFunction

Sub EscapeForFilePath(inout As BytePtr)
	Dim i As Long, check As Long
	Do
		if inout[i]=0 then exitdo			
		check = PathGetCharType(inout[i])
		if check=GCT_INVALID or (check And (GCT_SEPARATOR or GCT_WILD)) then
			inout[i]=GetByte("_")
		endif
		i++
	Loop
End Sub

'標準Windows
Function sprintfStr(lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord ) As String
	Dim Buf[PRINTF_BUFFER] As Byte,ret As Long
	ret=wsprintf(Buf,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	sprintfStr=MakeStr(Buf)
EndFunction

'使うとVCランタイム要求になる
Function doubleToFormatStr(lpFormat As BytePtr)(a As Double) As String
	Dim Buf[PRINTF_BUFFER] As Byte,ret As Long
	ret=sprintfd(Buf,lpFormat,a)
	doubleToFormatStr=MakeStr(Buf)
EndFunction

' =========================
' ファイルの容量などを単位付き文字列にする関数(64bit対応)
' =========================
Const DC2T_BUFFER_SIZE = 16
Function DataCap2Text(val As QWord, text As BytePtr, length As DWord)(isLastDigit As BOOL) As BytePtr
	Dim buffer[DC2T_BUFFER_SIZE-1] As Byte

	Const DC2T_UNIT_IDX_COUNT = 4
	Dim unitTable[DC2T_UNIT_IDX_COUNT] = ["Byte", "KB", "MB", "GB", "TB"/*, "PB", "EB"*/] As BytePtr
	Dim unitIndex As Long
	Dim lastDigit As Long
	Dim size As QWord
	Dim sign As BytePtr

	if val > &H8000000000000000 Then
		sign = "-"
		size = val * -1
	Else
		sign = ""
		size = val
	End If

	unitIndex = 0
	lastDigit = 0
	Do
		if size < 1024 Then ExitDo
		if unitIndex >= DC2T_UNIT_IDX_COUNT Then ExitDo
		lastDigit = ((size Mod 1024) * 10) / 1024
		size = size/1024
		unitIndex++
	Loop

	'QWordをcdeclの可変長引数に突っ込むと死ぬので
	Dim dwSize As DWord
	dwSize = size
	if lastDigit=0 Or isLastDigit=FALSE Then
		wsprintf(buffer, ex"%s%d %s",sign,dwSize,unitTable[unitIndex])
	Else
		wsprintf(buffer, ex"%s%d.%d %s",sign,dwSize,lastDigit,unitTable[unitIndex])
	Endif

	if length < DC2T_BUFFER_SIZE Then
		memcpy(text, buffer, length)
	Else
		memcpy(text, buffer, lstrlen(buffer)+1)
	End If
	
End Function

' String型
Function DataCap2Text_Str(val As QWord)(isLastDigit As BOOL) As String
	Dim buffer[DC2T_BUFFER_SIZE-1] As Byte
	DataCap2Text(val,buffer,DC2T_BUFFER_SIZE,isLastDigit)
	DataCap2Text_Str=MakeStr(buffer)
End Function

' Print
Sub PrintDataCap(val As QWord)(isLastDigit As BOOL)
	Dim buffer[DC2T_BUFFER_SIZE-1] As Byte
	DataCap2Text(val,buffer,DC2T_BUFFER_SIZE,isLastDigit)
	PrintPtr(buffer)
End Sub


'(文字列, 変換結果を入れるところ, 基数, 1024か1000か)
Function rcAsciiToInt(_str As BytePtr,result_num As *Long)(_base As DWord,b1024 As BOOL) As BOOL
	Dim ci As DWord, ni As DWord 'char index, num index
	Dim fNegative As BOOL, fFixedBase As BOOL
	Dim base As DWord, siZoom As DWord
	Dim num As DWord
	Dim state As DWord
	Dim str As BytePtr

	'基数
	'引数のbaseが0だとAuto, それ以外は固定, 最大１６まで
	if _base=<1 Then	
		base = 10
	Else 
		base=_base
		fFixedBase=TRUE
	End If

	'si接頭辞があるときに、1000で計算するか1024で計算するか
	if b1024 Then
		siZoom=1024
	Else
		siZoom=1000
	End If

	str=calloc(lstrlen(_str)+4)
	lstrcpy(str,_str)
	CharLower(str)

	Do 
		'文字列の終了チェック
		if str[ci]=0 Then ExitDo

		'数値に入る前の処理
		if state=0 Then
			if str[ci] = &H2D Then
				fNegative=TRUE
				ci++
				continue
			Else if str[ci] = &H30 then
				'16進 0x
				if str[ci+1]=&H78 Then
					base=16
					ci+=2
					continue

				'2進 0b
				Else if str[ci+1]=&H62 Then
					base=2 
					ci+=2
					continue
				End If
			End If

			'数値だったら数値解析ステートに移る
			if (str[ci] >= &H30 And str[ci] <= &H39) or _
				(base=16 And (str[ci] >= &H61 And str[ci] <= &H66)) Then					
				state++

				'固定基数なのに変わってたらアウト
				if fFixedBase And (base <> _base) Then Goto *rcATOI_ERRNUM
			Else 
				ci++
				continue
			End If
		End If

		'数値処理
		if state=1 Then
			if (str[ci] >= &H30 And str[ci] <= &H39) Then
				if (str[ci]-&H30) => base Then Goto *rcATOI_ERRNUM
				num=num * base
				num=num + str[ci]-&H30
			Elseif (base=16 And (str[ci] >= &H61 And str[ci] <= &H66)) Then
				num = num * base 
				num = num + str[ci]-&H61 +10 
			Else 
				state++
			Endif
		End If

		'SI 接頭辞処理
		if state=2 Then 
			Select Case str[ci]
				Case &H6B
					num*=siZoom
				Case &H6D
					num*=siZoom*siZoom
				Case &H67
					num*=siZoom*siZoom*siZoom
				Case &H74 
					num*=siZoom*siZoom*siZoom*siZoom
			End Select
			ci++
			state++
		End If

		if state=3 Then 
			if isSameBin(str+ci,"bit",3) Then
'				num=num/8
				num=num>>3
			End If
			state++
		End If

		if state=4 Then ExitDo

		ci++

	Loop

	if fNegative Then	num*=-1
#ifdef _DEBUG
	printf(ex"[atoi@RGBA-CRT]str = %s\nfNegative = %d\nbase = %d\nnum = %d\nnum = 0x%X\nnum = %dK\n\n", _
		str			 As DWord, _
		fNegative	 As DWord, _
		base, _
		num, _
		num, _
		(num/siZoom) As DWord)
#endif

	rcAsciiToInt=TRUE
	SetDWord(result_num,num)
	ExitFunction

*rcATOI_ERRNUM
	rcAsciiToInt=FALSE
End Function

'------------------------------
'		Network library
'------------------------------

'URLのパーセントエンコードを解除
Function URLDecode(pFrom As BytePtr) As BytePtr
   	Dim i = 0 As DWord
	Dim ASCII As Byte
	URLDecode=calloc(MAX_PATH+5)

   Do 
		if pFrom[i]=&H25 Then '% then
			ASCII=Hex2Dec(Chr$(pFrom[i+1])+Chr$(pFrom[i+2])) As Byte
			lstrcat(URLDecode , Chr$(ASCII))
			i=i+2
		Else
			lstrcat(URLDecode , Chr$(pFrom[i]))
		EndIf
		i++			
		if pFrom[i] = 0 Then ExitDo
   Loop
End Function

'軽量化のため、移動
'Function GetHttpStatusText(HttpStatusNo As Long)

'-------------------------------------
'  Dynamic DLL Loader + cdeclLoader
'-------------------------------------
Type DLL_FUNCTION_CELL
	'関数ポインタを格納するための変数へのポインタ
	ptr As VoidPtr
	'DLLから探す関数名
	alias As BytePtr
EndType

Function GetSystemErrorMessage(ByRef textBuffer As BytePtr, ErrCode As DWord) As DWord
	GetSystemErrorMessage = _
		FormatMessage( _
				FORMAT_MESSAGE_ALLOCATE_BUFFER or FORMAT_MESSAGE_FROM_SYSTEM or FORMAT_MESSAGE_IGNORE_INSERTS, _
	  			NULL, ErrCode, LANG_USER_DEFAULT, VarPtr(textBuffer), 0, NULL _
		)
End Function

Function DynamicDllLoader(DllName As BytePtr,func_list As *DLL_FUNCTION_CELL,count As Long, bMsgOutput As BOOL)(opt_text As BytePtr,hWnd As HWND) As HINSTANCE
	Dim hDll As HINSTANCE
	Dim mainErrMes As BytePtr

	' DLLロード
	hDll=LoadLibrary(DllName)

	' エラー処理
	if hDll=0 Then
		' エラーメッセージ作成（有効なら
		if bMsgOutput Then
			if opt_text=0 Then opt_text=""
			mainErrMes=calloc(1024)
			wsprintf(mainErrMes,ex"%s%sのロードに失敗しました。",DllName,opt_text)
		End If

		Goto *DDL_RETURN_ERROR
	EndIf

	' 関数ロードループ
	Dim i As Long
	For i = 0 To count-1
		' 代入先ポインタチェック
		if func_list[i].ptr=0 or func_list[i].alias=0 Then Goto *DDL_RETURN_ERROR
		
		'Func_List.ptrの先に関数ポインタを格納
		SetDWord(func_list[i].ptr,GetProcAddress(hDll,func_list[i].alias))	

		'取得エラー
		if GetDWord(func_list[i].ptr)=NULL Then
			if bMsgOutput Then
				if opt_text=0 Then opt_text=""
				mainErrMes=calloc(1024)
				wsprintf(mainErrMes,ex"%sから関数が見つかりませんでした。\nDLLのバージョンを確認してください。\nProcName : %s",DllName,func_list[i].alias)
			End If

			Goto *DDL_RETURN_ERROR
		EndIf
	Next i

	' 正常終了
	DynamicDllLoader=hDll
	ExitFunction


*DDL_RETURN_ERROR
	'エラー終了時
	DynamicDllLoader=NULL

	if hDll<>NULL Then _
		FreeLibrary(hDll)

	if mainErrMes<>NULL Then 
		Dim SysErrMes As BytePtr, SysErrMesLen As DWord
		' システムエラーメッセージを取得
		SysErrMesLen = GetSystemErrorMessage(ByVal VarPtr(SysErrMes),GetLastError())

		if SysErrMesLen + lstrlen(mainErrMes) < 1024 Then
			wsprintf(mainErrMes + lstrlen(mainErrMes), ex"\nErrorCode: %d\n%s",GetLastError(),SysErrMes)
		Endif

		MessageBox(hWnd,mainErrMes,"DLL Load Error",MB_ICONERROR)

		LocalFree(SysErrMes) : SysErrMes = NULL
		free(mainErrMes)
	EndIf
EndFunction

'バイナリに実行可能属性追加
Function SetAsm(asm As *Byte, codesize As Long) As VoidPtr
	SetAsm=VirtualAlloc(NULL, codesize, MEM_COMMIT, PAGE_EXECUTE_READWRITE) '追加
	memcpy(SetAsm,asm,codesize)
End Function

'↑開放
Sub FreeAsm(func As VoidPtr)
	VirtualFree(func, 0, MEM_DECOMMIT or MEM_RELEASE) '追加
End Sub

' ==========================================
'  cdeclLoaderはabcdecl.sbpに引っ越しました
' ==========================================

/* ==========================================
 * arg() : 可変引数 -> 配列化関数
 * ==========================================
 *
 * 	ActiveBasicの可変引数は、省略部分を自動でゼロをセットするようになっている。
 *  printf的な関数を実装するときは省略可能引数を大量に並べる必要があるが、
 *  引数が1つであれ4つであれ、ゼロをセットする命令が大量に並ぶことになる。
 *  argは引数の数分だけ関数を用意することでゼロをセットする命令を削減することができる。
 *  詳しくは逆汗して
 *  ゼロをセットする処理よりこっちの方式のほうがメモリアクセスが多いので遅いかもしれない
 */

'スタックがそのまま配列になっているので、_argにコピーする
'スレッドセーフじゃないけど、滅多に使わないので現状このままで　
Typedef ARGT = Long
Dim _arg[15] As ARGT

Function arg() As *ARGT
	arg=_arg
End Function

Function arg(a As ARGT) As *ARGT
	_arg[0]=a
	arg=_arg
End Function

Function arg(a As ARGT,b As ARGT) As *ARGT
	_arg[0]=a
	_arg[1]=b
	arg=_arg
End Function

Function arg(a As ARGT, b As ARGT, c As ARGT ) As *ARGT
	memcpy(_arg,VarPtr(a),12)
	arg=_arg
End Function

Function arg(a As ARGT, b As ARGT, c As ARGT, d As ARGT) As *ARGT
	memcpy(_arg,VarPtr(a),16)
	arg=_arg
End Function

Function arg(a As ARGT, b As ARGT, c As ARGT, d As ARGT,e As ARGT ) As *ARGT
	memcpy(_arg,VarPtr(a),20)
	arg=_arg
End Function

Function arg(a As ARGT,b As ARGT,c As ARGT ,d As ARGT ,e As ARGT ,f As ARGT) As *ARGT
	memcpy(_arg,VarPtr(a),24)
	arg=_arg
End Function

Function arg(a As ARGT,b As ARGT,c As ARGT ,d As ARGT ,e As ARGT ,f As ARGT,g As ARGT) As *ARGT
	memcpy(_arg,VarPtr(a),28)
	arg=_arg
End Function

Function arg(a As ARGT,b As ARGT,c As ARGT ,d As ARGT ,e As ARGT ,f As ARGT,g As ARGT,h As ARGT ) As *ARGT
	memcpy(_arg,VarPtr(a),32)
	arg=_arg
End Function

Function arg(a As ARGT,b As ARGT,c As ARGT ,d As ARGT ,e As ARGT ,f As ARGT,g As ARGT,h As ARGT ,i As ARGT) As *ARGT
	memcpy(_arg,VarPtr(a),36)
	arg=_arg
End Function

Function arg(a As ARGT,b As ARGT,c As ARGT ,d As ARGT ,e As ARGT ,f As ARGT ,g As ARGT ,h As ARGT ,i As ARGT ,j As ARGT ,k As ARGT ,l As ARGT ,m As ARGT ,n As ARGT) As *ARGT
	memcpy(_arg,VarPtr(a),60)
	arg=_arg
End Function

'printfはこちらを推奨だが、パフォーマンス対して変わらないのでセーフとする
Dim _print_buf[1024] As Byte,_print_len As Long
Sub printf2(format As BytePtr,arglist As *ARGT)
	_print_len=wvsprintf(_print_buf,format,arglist)
	PrintPtr(_print_buf,_print_len)
Endsub

'------------------------------
'		Console library
'------------------------------

Function GetConsoleCursorDw() As DWord
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	memcpy(VarPtr(GetConsoleCursor),CmdPos.dwCursorPosition,sizeof(DWord))
EndFunction

SUb GetConsoleCursor(ByRef pos As COORD)
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	memcpy(VarPtr(pos),VarPtr(CmdPos.dwCursorPosition),sizeof(DWord))
EndSub

Sub ConsoleReturnLine()
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	CmdPos.dwCursorPosition.X=0
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	
EndSub

Sub ConsoleLocateRelative(x As Long,y As Long)
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos) As DWORD)
	CmdPos.dwCursorPosition.X += x
	CmdPos.dwCursorPosition.Y += y
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	
EndSub

Sub ConsoleClearCurrentLine()
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos) As DWORD)
	CmdPos.dwCursorPosition.X = 0
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	
	print String$(CmdPos.dwSize.X," ")
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	

EndSub

Sub ConsoleReturnChar(count As Long)
	Dim CmdPos As CONSOLE_SCREEN_BUFFER_INFO
	GetConsoleScreenBufferInfo (_System_hConsoleOut,VarPtr(CmdPos))
	CmdPos.dwCursorPosition.X-=count
	SetConsoleCursorPosition(_System_hConsoleOut,GetDWord(VarPtr(CmdPos.dwCursorPosition)))	
EndSub

Enum ABRLC_COLOR
	CC_DEFAULT
	CC_BLUE		= &H01
	CC_GREEN	= &H02
	CC_RED		= &H04
End Enum

Sub SetConsoleColor(color As ABRLC_COLOR)
	Dim attr As Word

	if color=CC_DEFAULT Then 
		attr=CC_BLUE or CC_GREEN or CC_RED
	Else
		attr=color And &H07
	End If

	'attr = attr or &H56

	SetConsoleTextAttribute(_System_hConsoleOut,attr)
End Sub

'コンソールのウィンドウハンドルを取得
Function GetConsoleWndHandle() As HANDLE
	dim hConsole As HWND
	SetConsoleTitle("_FIND_STRING_RGBA_CRT_") 
	Sleep(40) 
	hConsole=FindWindow(NULL, "_FIND_STRING_RGBA_CRT_")
EndFunction

'コンソールのアイコンを変更
Sub SetConsoleIcon(IconID As DWord)
	SendMessage(GetConsoleWndHandle(),WM_SETICON,ICON_SMALL,LoadImage(GetModuleHandle(0),IconID As BytePtr,IMAGE_ICON,GetSystemMetrics(SM_CXSMICON),GetSystemMetrics(SM_CYSMICON),LR_DEFAULTCOLOR) As Long)
EndSub

Const PRINTF_BUFFER = 1024
Sub printf(lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,
	f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord )
	'Dim Buf[PRINTF_BUFFER] As Byte,ret As Long	
	_print_len=wsprintf(_print_buf,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	PrintPtr(_print_buf,_print_len)
EndSub

Sub PrintPtr(Text As BytePtr)(Length As Long)
	Dim a As Long
	if Length=0 then 
		a=lstrlen(Text)
	Else
		a=Length
	End If
	WriteFile(_System_hConsoleOut,Text,a,VarPtr(a),ByVal NULL)
	'WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),Text,Length,NULL
Endsub

Sub PauseConsole()
	Dim buf As DWord
	WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),ex"[PRESS ANY KEY]\0",16,VarPtr(buf),ByVal NULL)
	ReadFile(GetStdHandle(STD_INPUT_HANDLE),VarPtr(buf),1,VarPtr(buf),ByVal NULL)
EndSub

Function Dump(Data As BytePtr,Size As DWORD)(VAdr As DWORD,noHeader As BOOL) As DWORD
	Dim buf[70] As Byte,p As BytePtr, i As Long,Adr As DWORD
		
	'SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), BACKGROUND_BLUE OR BACKGROUND_GREEN OR BACKGROUND_RED)
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), &H0070)
	if VAdr=0 Or noHeader=FALSE then PrintPtr( ex" ADDRESS  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  0123456789ABCDEF \n")
	SetConsoleTextAttribute(_System_hConsoleOut, 1 OR 2 OR 3 OR 4)
	Do
		SetConsoleTextAttribute(_System_hConsoleOut, &H10  OR 4 OR 3 )
		printf("%08X  ",Adr+VAdr)
		SetConsoleTextAttribute(_System_hConsoleOut, 1 OR 2 OR 3 OR 4)
'		Print " ";
		p=buf
		For i=0 To &H0F
			if Adr+i=>Size then
				p+=wsprintf(p, "-- ")
			Else 
				p+=wsprintf(p, "%02X ",Data[Adr+i])
			EndIf
		Next i
		p[0] = GetByte(" ")
		p++
		For i=0 To &H0F
			if Adr+i=>Size then 
				p[0] = GetByte(" ")
				p++
			Else
				if Data[Adr+i]<&H20 or Data[Adr+i]=&HFF then 
					p[0] = GetByte(".")
					p++
				Else
					p[0] = Data[Adr+i]
					p++
				EndIf
			endif
		Next i
		i=0
'		PrintPtr(ex"\n")
		p[0] = GetByte(ex" ")
		p[1] = GetByte(ex"\n")
		p[2] = 0
		PrintPtr(buf)
		'MessageBox(0,"L",0,0)
		Adr+=&H10
		if Adr+i=>Size then Goto *EXIT_LOOP
'		
	Loop
*EXIT_LOOP
	PrintPtr(ex"\n")
'	Print Hex$(Adr*&H10+i)+"="+Hex$(Size)
	Dump=Adr
EndFunction

Enum PRINT_HIGHLIGHT_COLOR
	PH_ERROR   = &H000C
	PH_SUCCESS = &H000A
End Enum

Sub colorPrint(color As DWord,str As BytePtr)
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE) , color )
	PrintPtr(str)
	SetConsoleColor(CC_DEFAULT)
End Sub

' WinAPI wrapper. this API is available on Vista or later.
Function SetConsoleOutputCP(cp AS Long) AS BOOL
	Dim func AS *Function(cp AS Long) AS BOOL
	func = GetProcAddress(GetModuleHandle("Kernel32"), "SetConsoleOutputCP")
	if func then
		SetConsoleOutputCP = func(cp)
	endif
End Function



'---------------
'	Device 
'---------------
Const MAXDWORD=&HFFFFFFFF
Function SetIOTimeOut(hComPortPort As HANDLE,TimeOut As DWord) As Byte
	Dim ct As COMMTIMEOUTS
	ct.ReadIntervalTimeout=100		'連続受信タイムアウト
	ct.ReadTotalTimeoutMultiplier=10
	ct.ReadTotalTimeoutConstant=TimeOut	'Constant+Multiplier*バイト数＝タイムアウト
	ct.WriteTotalTimeoutConstant=TimeOut
	ct.WriteTotalTimeoutMultiplier=10

	SetCommTimeouts(hComPortPort,VarPtr(ct))
EndFunction


TypeDef ESP_CALLBACK_T = *Function(userdata As VoidPtr, PortName As BytePtr, FriendlyName As BytePtr) As Long
Function EnumSerialPorts(setupapi As *SetupApiWrapper, callback As ESP_CALLBACK_T, userdata As VoidPtr) As BOOL
	EnumSerialPorts=FALSE
	Dim classGUID[0] As GUID
	Dim DeviceInfoData As SP_DEVINFO_DATA
	Dim dwReqSize As DWord

	'個々のコードはWin2000以降専用

	'Setup API の PortsのGUIDを取得 
	DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA)
	if setupapi->SetupDiClassGuidsFromName("Ports", classGUID, 1,VarPtr(dwReqSize)) = FALSE Then
		PrintPtr("GetClass Error")
	Endif

	Dim hDevInfoSet As HANDLE
	hDevInfoSet = setupapi->SetupDiGetClassDevs(VarPtr(classGUID[0]), NULL, NULL, DIGCF_PRESENT OR DIGCF_PROFILE)
	if hDevInfoSet = INVALID_HANDLE_VALUE Then ExitFunction
	
'	printf(ex"%s\n",GuidToText_calloc(classGUID))

	'レジストリrエントリを走査
	Dim EnumDeviceIndex As Long

	Do
		if setupapi->SetupDiEnumDeviceInfo(hDevInfoSet, EnumDeviceIndex, VarPtr(DeviceInfoData)) = FALSE Then ExitDo

		Dim regFriendlyName[MAX_PATH] As Byte
		Dim dwPropType As DWord

		'DevInfoDataから"USB-SERIAL CH340 (COM3)"などのフレンドリーネームを取得
		If setupapi->SetupDiGetDeviceRegistryProperty(
			hDevInfoSet,
			VarPtr(DeviceInfoData),
			SPDRP_DEVICEDESC,
			VarPtr(dwPropType),
			regFriendlyName,
			MAX_PATH,
			VarPtr(dwReqSize)
		) = FALSE Then ExitFunction

		' COM3　などのポート名を取得
		Dim hKey As HANDLE
		hKey = setupapi->SetupDiOpenDevRegKey(hDevInfoSet,VarPtr(DeviceInfoData),
				                            DICS_FLAG_GLOBAL, 0, DIREG_DEV, KEY_READ)
		if hKey = INVALID_HANDLE_VALUE Then ExitFunction
				
		Dim lpType As DWord, regReadSize As DWord
		Dim portName[10] As Byte
		regReadSize=10
		RegQueryValueEx(hKey,("PortName"),NULL,VarPtr(lpType),portName,VarPtr(regReadSize))
		portName[10]=0

		' Portsで列挙されるLPTを排除する
		If win_strncmpi(portName, "COM", 3) Then
			callback(userdata, portName, regFriendlyName)
		End If

		EnumDeviceIndex++
	Loop

	EnumSerialPorts=TRUE
EndFunction

Const GUID_TEXT_SIZE = 40
Function GuidToText_calloc(guid As *GUID) As BytePtr
	GuidToText_calloc=calloc(GUID_TEXT_SIZE)
	wsprintf(GuidToText_calloc, "{%08X-%04X-%04X-%04X-%04X%08X}", _
		guid->Data1,guid->Data2,guid->Data3,SwapWord(GetWord(guid->Data4)), _
		SwapWord(GetWord(guid->Data4+2)),ReverseDWord(GetDWord(guid->Data4+4))
	)
End Function

Function GetComBaudrate(hSerial As HANDLE) As DWord
	Dim dcb As DCB_SETTING
	GetCommState(hSerial, dcb)
	GetComBaudrate = dcb.BaudRate
End Function

Function SetComTimeOut(hSerialPort As HANDLE, TimeOut As DWord) As Byte
	Dim ct As COMMTIMEOUTS
	ct.ReadIntervalTimeout = TimeOut '連続受信タイムアウト
	ct.ReadTotalTimeoutConstant = TimeOut 'Constant+Multiplier*バイト数＝タイムアウト
	ct.ReadTotalTimeoutMultiplier = 20
	ct.WriteTotalTimeoutConstant = TimeOut
	ct.WriteTotalTimeoutMultiplier = 20
	
	SetCommTimeouts(hSerialPort, VarPtr(ct))
End Function

Sub ChangeComBaudrate(hSerial As HANDLE, rate As DWord)
	Dim dcb As DCB_SETTING
	GetCommState(hSerial, dcb)
	dcb.BaudRate = rate '転送速度の指定
	SetCommState(hSerial, dcb)
	
	FlushCom(hSerial)
	
	GetCommState(hSerial, dcb)
End Sub


'---------------
'	Math
'---------------
Function isNan(value As double) As Double
	Dim dw[1] As DWord
	memcpy(dw,VarPtr(value),8)

	if (((dw[1])>>(20) And &H7FFF)=2047) And (dw[0] or (dw[1] And &H0007FFFF))>0 Then
		isNan=TRUE
	End If
End Function

Function Nan() As Double
	Dim DWORD_H=&H7FF55577 As DWord
'	Dim DWORD_L=&HFF005599 As DWord
	memcpy(VarPtr(Nan)+4,VarPtr(DWORD_H),4)
'	memcpy(VarPtr(Nan)  ,VarPtr(DWORD_L),4)
End Function

/* bibun 関数の微分係数を出す
 * 	_func  : 微分したい関数へのポインタ
 *	inValue: 関数へ渡す値
 *	return = 微分係数
 */
Typedef FN_PROTO = *Function(x As Double) As Double
Function bibun(_func As FN_PROTO,inValue As Double) As Double
	bibun = (_func(inValue + EPS) - _func(inValue)) / EPS
End Function

Function newton(x1 As double,func As FN_PROTO) As double
	Dim x As double,xp As double,fdash As double,  c As Long
	x=x1
	Do
		xp=x

		fdash=bibun(func,xp)
		if fdash=0 Then fdash=EPS
		x = xp - (func(xp) / fdash)
		if Abs(x-xp) < EPS or c>ITER_LIMITTER Then ExitDo
		c++
	Loop

	newton=x
End Function

Function GetKaiLU(ByRef A As ABMatrix,ByRef b As ABMatrix) As *ABMatrix
	Dim L As *ABMatrix,U As *ABMatrix
	Dim y As *ABMatrix,tmp As *ABMatrix
	Dim sigma As DOUBLE,i As Long,k As Long
	x=new ABMatrix(b.y,b.x)
	y=new ABMatrix(b.y,b.x)

	A.GetLU(L,U)	
	For i = 0 To y->y-1
		sigma=0
		For k=0 To i-1
			sigma+=L->Get(i,k)*y->Get(k,0)
		Next k
		y->Set((b.Get(i,0)-sigma)/L->Get(i,i),i,0)
	Next i 

	For i = y->y-1 To 0 Step -1
		sigma=0
		For k=i To y->y-1
			sigma+=U->Get(i,k)*x->Get(k,0)
		Next k
		x->Set((y->Get(i,0)-sigma)/U->Get(i,i),i,0)
	Next i

	GetKaiLU=x
	delete y	:	delete L	:	delete U
End Function


Function MulMatrix(ByRef a As ABMatrix,ByRef b As ABMatrix) As *ABMatrix
	Dim ix As Long,iy As Long,is As Long
	Dim sum As double
	Dim ret As *ABMatrix
	ret=new ABMatrix(b.y,b.x)

	For iy=0 To ret->y-1
		For ix=0 To ret->x-1
			sum=0
			For is=0 To a.x-1
				sum+=a.Get(iy,is) * b.Get(is,ix)	
			Next is
			ret->Set( sum ,iy,ix)
		Next ix
	Next iy
	MulMatrix=ret
End Function

Function InputMatrix()(Message As BytePtr) As *ABMatrix
	Dim in As String
	Dim x As Long,ox As Long,i As Long, y As Long,dr[20] As *double
	if Message<>0 Then printf(ex"%s\n",Message)
	Do
		Input ">",in
		dr[y]=Str2DoubleAry(in,x)
		if dr[y]=NULL or x=0 Then Exitdo
		if i>0 And ox<>x Then Print "行列サイズが不正です。":ExitFunction
		ox=x
		i++:y++
		if y>20 then Print "行数制限です。":Exitdo
	Loop
	'サイズが0
	if y<1 or ox<1 Then 
		For i=0 To y-1
			free(dr[i])
		Next i
		ExitFunction
	EndIf

	InputMatrix=new ABMatrix(y,ox)
	For i=0 To y-1
		For x=0 To ox-1
			InputMatrix->Set(dr[i][x],i,x)
		Next x
		free(dr[i])
	Next i

	Print
End Function

Function Str2DoubleAry(str As BytePtr,ByRef count As Long) As *double	debug
	Dim i As Long,C As Long
	
	count=0
	if str=NULL then ExitFunction
	Str2DoubleAry=calloc(sizeof(double)*lstrlen(str)+10)

	Do
		if str[i]=0 Then ExitDo
		if str[i]<>Asc(" ") Then 
			Str2DoubleAry[C]=Val(str+i)
			C++
			'Skip to next space
			Do
				i++
				if str[i]=Asc(" ") Then Exitdo
				if str[i]=0 Then exitdo
			Loop
			continue
		End If
		i++
	Loop

	if C>0 Then
		realloc(Str2DoubleAry,sizeof(double)*(C))
		count=C
	Else
		free(Str2DoubleAry)
		Str2DoubleAry=0
	EndIf
End Function

Function CountChar(str As BytePtr,chara As Byte) As Long
	if str=NULL then ExitFunction
	Dim i As Long,C As Long
	Do
		if str[i]=chara Then C++
		if str[i]=0 Then ExitDo
		i++
	Loop
	CountChar=C
End Function

Function GetOsMajorVersion() As Long
	Dim Ver As OSVERSIONINFO
	Ver.dwOSVersionInfoSize=sizeof(OSVERSIONINFO)
	GetVersionEx(Ver)
	GetOsMajorVersion=Ver.dwMajorVersion
End Function

Function IsWin9x() As Long
	if GetOsMajorVersion() = 4 Then
		IsWin9x=TRUE
	Else
		IsWin9x=FALSE
	End If
End Function




'------------------------------
'		Class library
'------------------------------
Class File
Protected
	hFile As HANDLE
Public
	path As FilePath
	Function _openFile(_Mode As DWORD) As BOOL
		Dim CreateMode As Dword
		If _Mode=GENERIC_READ then
			CreateMode=OPEN_EXISTING
		Elseif  _Mode=GENERIC_WRITE then
			CreateMode=CREATE_ALWAYS
		Else
			CreateMode=OPEN_EXISTING
		EndIf

		hFile=CreateFile(path.GetPath(), _Mode, FILE_SHARE_READ or FILE_SHARE_WRITE, ByVal 0,CreateMode, FILE_ATTRIBUTE_NORMAL, 0)
		If hFile=INVALID_HANDLE_VALUE then 
			_openFile = FALSE
			hFile=0
		Else
			_openFile = TRUE
		EndIf
	EndFunction

	
	Function openFile(inPath As BytePtr,_Mode As DWORD) As BOOL
		path.SetPath(inPath)
		openFile=_openFile(_Mode)
	End Function
	
/*	Function openFileW(inPath As WordPtr,_Mode As DWORD) As BOOL
		path.SetPath(inPath)
		openFileW=_openFile(_Mode)
	End Function
*/
	Function read(dest As BytePtr,size As DWord) As Long
		Dim dwAB As BytePtr
		read=ReadFile(hFile,dest,size,VarPtr(dwAB),ByVal NULL) As Long
		If read=TRUE And dwAB=0 then
			read=-1 As Long	'EOF
		ElseIf read=FALSE then
			read=-2 As Long
		Else
			read=dwAB As Long
		EndIf
	End Function

	Function readDw() As Long
		read(VarPtr(readDw),sizeof(DWord))
	End Function

	Function write(source As BytePtr,size As DWord) As Long
		WriteFile(hFile,source,size,VarPtr(write),ByVal NULL)
	End Function

	Function getFilePtr() As DWord
		getFilePtr=SetFilePointer(hFile,0,0,FILE_CURRENT)
	EndFunction

	'up to 4GB
	Sub setFilePtr(fp As DWord)(fpHigh As DWord)
		'SetFilePointerの第3引数 lpDistanceToMoveHighをNULLにすると下位がLong扱いになる

		SetFilePointer(hFile,fp,VarPtr(fpHigh),FILE_BEGIN)
	End Sub

	Sub addFilePtr(fp As DWord)
		SetFilePointer(hFile,fp,0,FILE_CURRENT)
	End Sub

	Function length() As Long
		if hFile = 0 Then length=0 : Exitfunction
		length=GetFileSize(hFile,NULL)
	EndFunction

	Function lengthEx(ByRef highDWord As DWord) As Long
		if hFile = 0 Then length=0 : Exitfunction
		length=GetFileSize(hFile, VarPtr(highDWord))
	EndFunction

	Function lengthQWord() As QWord
		if hFile = 0 Then lengthQWord=0 : Exitfunction
		Dim lowDWord As DWord, highDWord As DWord
		lowDWord=GetFileSize(hFile, VarPtr(highDWord))
		lengthQWord = lowDWord OR (highDWord As QWord)<<32
	EndFunction

	Function getHandle() As HANDLE
		getHandle=hFile
	EndFunction

	Sub setHandle(_handle As HANDLE)
		hFile=_handle
	End Sub
	
	Function getPath() As BytePtr
		getPath=path.GetPath()
	EndFunction

	Sub close()
		CloseHandle(hFile)
		hFile=0
		path.Destroy()
	End Sub
End Class

'ファイルパス用クラス
'OS required: Win95 with IE4 later
Class FilePathW
Protected
	pathStr As StringClassW
	nullidx As DWord
	separator As Word	' \
Public

	Sub FilePathW()
		setPathSeparator(ex"\\\0" As WordPtr)
		SetPath(ex"\0" As WordPtr)
	End Sub

	Sub setPathSeparator(newSeparator As WordPtr)
		separator=newSeparator[0]
	End Sub

	Sub setPathSeparatorChar(newSeparator As Word)
		separator=newSeparator
	End Sub

	'ファイルかフォルダかはわからないけどパスがセットされた
	Sub SetPath(path As WordPtr)
		'ダブルクォーテーションを削除しつつメモリ確保＆格納
		Dim nmlizePath As WordPtr
		NormalizePathW_AutoAlloc(path, VarPtr(nmlizePath))
		pathStr.set(nmlizePath)
		free(nmlizePath)

		nullidx=pathStr.length()
	EndSub

	Sub SetPathA(path As BytePtr) 
		Dim pathW As WordPtr
		Ansi2Wide_AutoAlloc(path, VarPtr(pathW))
		SetPath(pathW)
		free(pathW)
	End Sub

	Sub FileDlgSetupW(ofn As *OPENFILENAME,hWnd As HWND,opt As DWord,defFileName As WordPtr,defExt As WordPtr,extList As WordPtr)
		'ファイルオープン構造体の初期化
		ofn->lStructSize = sizeof(OPENFILENAME)
		ofn->hwndOwner = hWnd
		ofn->lpstrFilter = extList As BytePtr
		ofn->nFilterIndex = 0
		ofn->nMaxFile = MAX_PATH
		ofn->Flags=opt
		ofn->lpstrDefExt=defExt As BytePtr
		ofn->lpstrFile = malloc(MAX_PATH*2+4)
		if defFileName<>NULL Then _
			wcscpy(ofn->lpstrFile As WordPtr,defFileName)
	End Sub

	Function SaveFileDlg(hWnd As HWND,defFileName As WordPtr,defExt As WordPtr,extList As WordPtr) As Long
		Dim ofn As OPENFILENAME
		FileDlgSetupW(VarPtr(ofn),hWnd,OFN_OVERWRITEPROMPT,defFileName,defExt,extList)
		SaveFileDlg = GetSaveFileNameW(ofn)
		if SaveFileDlg Then
			SetPath(ofn.lpstrFile As WordPtr)
		End If
		free(ofn.lpstrFile)
	End Function

	Function OpenFileDlg(hWnd As HWND,defFileName As WordPtr,defExt As WordPtr,extList As WordPtr) As Long
		Dim ofn As OPENFILENAME
		FileDlgSetupW(VarPtr(ofn),hWnd,OFN_OVERWRITEPROMPT,defFileName,defExt,extList)
		GetOpenFileNameW(ofn)
		
		SetPath(ofn.lpstrFile As WordPtr)
		free(ofn.lpstrFile)
	End Function



	'フォルダを一階層下げるなどの用途がある
	Sub PushFile(filename As WordPtr)
		if nullidx<>0 And pathStr.ptr[nullidx-1]<>separator Then
			pathStr.addChar(separator)
		End If
		pathStr.cat(filename)
	EndSub

	Sub PushDir(SubDir As WordPtr)
		PushFile(SubDir)
		pathStr.addChar(separator)
	EndSub

	'ディレクトリから出る
	Sub PopDir()
		Dim i As Long
		For i = pathStr.length()-2 To 0 Step -1
			if pathStr.ptr[i]=separator Then	ExitFor
			if pathStr.ptr[i]=GetWord(ex":\0") Then ExitSub
		Next i
		pathStr.TerminateChar(i+1)
		'Base[i+1]=0
	EndSub
	
	'拡張子削除
	Sub deleteExtension()
		Dim extPtr As WordPtr
		extPtr=PathFindExtensionW(pathStr.ptr)

		if extPtr=NULL Then ExitSub

		extPtr[0]=0
		nullidx=extPtr-pathStr.ptr
	End Sub

	'文字列やファイル名など追加
	Sub cat(text As WordPtr)
		pathStr.cat(text)
	EndSub

	'ファイル存在チェック
	Function isExist() As Long
		isExist=PathFileExistsW(pathStr.ptr)
	EndFunction

	Function isDir() As Long
		if PathIsDirectoryW(pathStr.ptr) Then 
			isDir=TRUE
		Else
			isDir=FALSE
		EndIf
	EndFunction

	Function GetPathString() As String
		GetPathString=pathStr.getString()
	EndFunction

	Function genAddedPath(additionalPath As WordPtr) As String
		Dim tmp As FilePathW
		tmp.PushFile(additionalPath)
		genAddedPath=tmp.GetPathString()
	EndFunction

	Function GetPath() As WordPtr
		GetPath=pathStr.ptr
	EndFunction

	Function CopyPathToBuf(dstText As WordPtr, dstLen As DWord) As DWord
		CopyPathToBuf=pathStr.cpyTo(dstText, dstLen)
	EndFunction

	Function GetPathA() As String
		GetPathA=MakeStr(pathStr.GetAnsi())
	EndFunction

	Function CopyPathToBufA(dstText As BytePtr, dstLen As DWord, useShortPathWhenNonAnsiPath As BOOL) As DWord
		CopyPathToBufA=Wide2AnsiEx(pathStr.ptr, dstText, dstLen)
		' Wide文字で表せないパスが来たら短いパス名に変換してごまかす
		' 9xでは大体FAT32なので
		if PathFileExists(dstText) <> TRUE And useShortPathWhenNonAnsiPath then
			Dim lbuf[MAX_PATH] As Word
			GetShortPathNameW(pathStr.ptr, lbuf, 4096)
			Dump(lbuf As BytePtr,128)
			Wide2AnsiEx(lbuf, dstText, dstLen)
		End If
	EndFunction

	Function GetPathExA(dstText As *FilePath, useShortPathWhenNonAnsiPath As BOOL) As DWord
		Const _GPEA_LBUF_LEN = MAX_PATH*2
		Dim lbuf[_GPEA_LBUF_LEN] As Byte
		GetPathExA = CopyPathToBufA(lbuf, _GPEA_LBUF_LEN, useShortPathWhenNonAnsiPath)
		dstText->SetPath(lbuf)
	EndFunction

	Function GetFileName() As WordPtr
		GetFileName=PathFindFileNameW(pathStr.ptr)
	EndFunction

	Function GetFileExt() As WordPtr
		GetFileExt=PathFindExtensionW(pathStr.ptr)
	EndFunction

	Function GetFileDirString() As String
		Dim tmp As FilePathW
		tmp.setPathSeparatorChar(separator)
		tmp.SetPath(pathStr.ptr)
		tmp.PopDir()
		GetFileDirString=tmp.GetPathString()
	EndFunction

	Sub Destroy()
		pathStr.freeStr()
		nullidx=0
	EndSub

	Function Length() As DWord
		Length=nullidx
	EndFunction

	Sub ~FilePathW()
		Destroy()
	EndSub
End Class

Function GetDragFilePath(hDrop As HDROP, iFile As Long, FilePathInstance As *FilePathW) As BOOL
	Const _GDFP_CBUF_LEN = MAX_PATH*2+4
	Dim cbuf[_GDFP_CBUF_LEN] As Word
	Dim dbuf As WordPtr, dbuflen AS DWord
	Dim ret AS DWord

	if __isWin9x then
		' 9xはたいていFAT32上で動いているのでMAX_PATHより大きなバッファを使っていれば可変長対応が不要だろうと判断
		ret = DragQueryFile(hDrop, iFile, cbuf As BytePtr, _GDFP_CBUF_LEN)
		if ret Then
			FilePathInstance->SetPathA(cbuf As BytePtr)
		End If
	Else
		ret = DragQueryFileW(hDrop, iFile, NULL, 0)
		if ret = 0 Then
			ExitFunction
		Elseif ret >= _GDFP_CBUF_LEN then
			dbuflen = ret
			dbuf = malloc(dbuflen)
		Else
			dbuflen = _GDFP_CBUF_LEN
			dbuf = cbuf
		End If

		ret = DragQueryFileW(hDrop, iFile, dbuf, dbuflen)
		
		FilePathInstance->SetPath(dbuf)
		
		if dbuf <> cbuf Then free(dbuf)
	End If

	GetDragFilePath = ret
End Function

Const STRCLASS_SPF_BUFFER_WIDE = 1024*2
Class StringClassW
Private
	nullidx As DWord	'nullpos
	size As DWord	'buffer size
	ptrA As BytePtr	'string(ANSI)
Public
	ptr As WordPtr	'string

	Function cat(text As WordPtr) As Long
		Dim txlen As DWord
		txlen=lstrlenW(text)
		requestBuffer(txlen*2)
		if (nullidx+txlen)*2 >= size Then allocStr(txlen*2+size)
		memcpy(ptr+nullidx*2,text,txlen*2)
		nullidx+=txlen
		ptr[nullidx]=0
	EndFunction

	Sub insertHead(newStr As WordPtr)
		Dim tmp As WordPtr
		copyToNewPtr(tmp)
		set(newStr)
		cat(tmp)
	End Sub

	Sub replaceChar(old As *Word,newc As *Word)
		if nullidx=0 Then ExitSub
		Dim i As Long
		Do
			if ptr[i]=0 Then ExitSub
			if ptr[i]=old[0] Then ptr[i]=newc[0]
			i++
		Loop
	End Sub

	'
	Sub requestBuffer(len As Long)
		if len > size Then allocStr(len+size)
	End Sub
	Sub requestAdditionalBuffer(len As Long)
		requestBuffer(nullidx*2+len)
	End Sub

	Sub addChar(char As Word)
		requestBuffer(nullidx+2)
		ptr[nullidx]=char
		nullidx++
		ptr[nullidx]=0
	End Sub

	Function cpyFrom(text As WordPtr) As Long
		Dim txlen As DWord
		txlen=lstrlenW(text)
		if txlen*2 > size Then allocStr(txlen*2)
		memcpy(ptr,text,txlen)
		nullidx=txlen
		ptr[nullidx]=0
	EndFunction

	Function cpyTo(dst As WordPtr, dstlen As Dword) As Long
		Dim cpySize As Long
		cpySize = nullidx
		if cpySize > (dstlen-1) then cpySize = dstlen-1
		memcpy(dst, ptr, (cpySize+1)*2)
	End Function

	Function length() As DWord
		length=nullidx
	EndFunction

	Function cmp(text As WordPtr) As Long
		cmp=lstrcmpW(ptr,text)
	EndFunction
	Function cmpi(text As WordPtr) As Long
		cmp=lstrcmpiW(ptr,text)
	EndFunction

	Function sprintf(lpFormat As WordPtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord )
		Dim txlen As DWord
		txlen=lstrlenW(lpFormat)
		if txlen+STRCLASS_SPF_BUFFER_WIDE+nullidx > size then allocStr(txlen*2+STRCLASS_SPF_BUFFER_WIDE+nullidx*2)
		nullidx+=wsprintfW(ptr+nullidx*2,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	EndFunction

	Sub set(text As WordPtr)
		freeStr()
		nullidx=lstrlenW(text)
		allocStr(nullidx*2)
		memcpy(ptr,text,nullidx*2)
	EndSub

	Sub copyToNewPtr(ByRef dest As WordPtr)
		dest=calloc(nullidx*2+2)
		memcpy(dest,ptr,nullidx*2+1)
	endSub

	Sub update()
		nullidx=lstrlenW(text)
		size=nullidx*2
	EndSub

	Sub TerminateIndex(pos As DWord)
		ptr[pos]=0
		nullidx=pos
	EndSub


	Sub allocStr(newSize As DWord)
		size=newSize+5
		if ptr=0 Then 
			ptr=calloc(size)
		Else
			ptr=realloc(ptr,size)
		EndIf
	EndSub

	Sub freeStr()
		if ptr<>0 Then free(ptr):	ptr=NULL
		if ptrA	<> NULL Then free(ptrA):	ptrA=NULL
		nullidx=0
		size=0
	EndSub

	Sub slimMem()
		ptr=realloc(ptr,nullidx*2+1)
		size=nullidx*2+1
	EndSub

	Function getString() As String
		getString=MakeStr(GetAnsi())
	EndFunction

	Function GetAnsi() As BytePtr
		if ptrA	<> NULL Then free(ptrA)

	   ' UnicodeからShift-JISに変換
		ptrA=Wide2Ansi(ptr)
	   
		GetAnsi=ptrA
	End Function

	Sub StringClassW()
		ptr=NULL
	EndSub

	Sub ~StringClassW()
		freeStr()
	EndSub

End Class

'コマンドライン分割ライブラリ
Class CommandLine
private 
	cmdStr As BytePtr
	count As Long
	table As *BytePtr

	Sub freeMem()
		if cmdStr<>0 Then free(cmdStr):cmdStr=0
		if table<>0 Then free(table):table=0
		count=0
	EndSub

	Function SkipDQ(text As BytePtr,txlen As Long,offset As Long) As Long
	'	Print
		Dim i As Long
		For i = offset To txlen
			if text[i]=Asc(ex"\q") then ExitFor	
		Next i
		SkipDQ=i-offset+1
	End Function
Public
	Sub CommandLine()(text As BytePtr)
		if text=0 Then
			ParseCommandLine(GetCommandLine())
		Else
			ParseCommandLine(text)
		EndIf
	EndSub
	Sub ~CommandLine()
		freeMem()
	EndSub

	Function GetCount() As Long
		GetCount=count
	EndFunction

	Function GetCmd(index As DWord) As BytePtr
		if index>count-1 Then GetCmd="":ExitFunction
		GetCmd=table[index]
	EndFunction

	Function GetCmdWithDefault(index As DWord, default AS BytePtr) As BytePtr
		if index>count-1 Then GetCmdWithDefault=default:ExitFunction
		GetCmdWithDefault=table[index]
	EndFunction

	Function GetCmdString(index As DWord) As String
		GetCmdString=MakeStr(table[index])
	EndFunction

	'コマンドラインオプションチェック用
	Function cmpCmd(index As DWord,cmptext As BytePtr) As Byte
		if index>count Then cmpCmd=FALSE : ExitFunction
		if lstrcmpi(table[index],cmptext)=0 Then
			cmpCmd=TRUE
		Else
			cmpCmd=FALSE
		EndIf
	EndFunction

	Function ParseCommandLine(text As BytePtr) As Long
'		OutputDebugString(ex"called\n")
		if cmdStr<>0 Then freeMem()
		'確保
		Dim txlen As Long
		txlen=lstrlen(text)
		cmdStr=calloc(txlen+5)
		memcpy(cmdStr,text,txlen+1)

		'スペースを数える
		Dim ExpectedCount=0 As Long
		Dim i As Long
		For i = 0 To txlen
			if cmdStr[i]=Asc(" ") Then 
				ExpectedCount++
			EndIf
		Next i

		'スペースの分だけテーブルを確保,構築
		table=calloc(sizeof(BytePtr)*(ExpectedCount+2)+4)
		count = 0

		Dim it=0 As Long	'table index
		For i = 0 To txlen-1
			if cmdStr[i]<>Asc(" ") and cmdStr[i]<>0 Then
				'register to table
				table[it]=cmdStr+i
				it++

				For i = i To txlen
					if cmdStr[i]=Asc(" ") Then Exitfor
					if text[i]=Asc(ex"\q") then	i+=SkipDQ(cmdStr,txlen,i+1)':Print "!"
				Next i

				'tarminate 1 opt
				cmdStr[i]=0
			EndIf 
		Next i
		count=it
		it++
		table[it]=0
	EndFunction
End Class
/*
	1.空白以外の文字発見＝有効な文字列の先頭　-＞　テーブルに保存
	2.次のスペースまでスキップ
		2.5 そのうちにダブルクォーテーション見つけたら、スキップ -> DQ内のスペースは分割されない
	3.goto 1 (ｺﾚにより、余分なスペースがいなくなる)
*/
Class CommandLineW
private 
	cmdStr As WordPtr
	count As Long
	table As *WordPtr

	Sub freeMem()
		if cmdStr<>0 Then free(cmdStr):cmdStr=0
		if table<>0 Then free(table):table=0
		count=0
	EndSub

	Function SkipDQ(text As WordPtr,txlen As Long,offset As Long) As Long
	'	Print
		Dim i As Long
		For i = offset To txlen
			if text[i]=Asc(ex"\q") then ExitFor	
		Next i
		SkipDQ=i-offset+1
	End Function
Public
	Sub CommandLineW()(text As WordPtr)
		if text=0 Then
			ParseCommandLine(GetCommandLineW())
		Else
			ParseCommandLine(text)
		endif
	EndSub

	Sub ~CommandLineW()
		freeMem()
	EndSub

	Function GetCount() As Long
		GetCount=count
	EndFunction

	Function GetCmd(index As DWord) As WordPtr
		if index>count-1 Then
			GetCmd=ex"\0" As WordPtr
			ExitFunction
		End If
		GetCmd=table[index]
	EndFunction

	Function GetCmdString(index As DWord) As String
		GetCmdString=MakeStr(table[index])
	EndFunction

	'コマンドラインオプションチェック用
	Function cmpCmd(index As DWord,cmptext As WordPtr) As Byte
		if index>count Then cmpCmd=FALSE : ExitFunction
		if lstrcmpiW(table[index],cmptext)=0 Then
			cmpCmd=TRUE
		Else
			cmpCmd=FALSE
		endif
	Endfunction

	Function ParseCommandLine(text As WordPtr) As Long
'		OutputDebugString(ex"called\n")
		if cmdStr<>0 Then freeMem()
		'確保
		Dim txlen As Long
		txlen=lstrlenW(text)
		cmdStr=calloc(txlen*sizeof(Word)+5)
		memcpy(cmdStr,text,txlen*sizeof(Word)+1)

		'スペースを数える
		Dim ExpectedCount=0 As Long
		Dim i As Long
		For i = 0 To txlen
			if cmdStr[i]=Asc(" ") Then 
				ExpectedCount++
			endif
		Next i

		'スペースの分だけテーブルを確保,構築
		table=calloc(sizeof(WordPtr)*(ExpectedCount+2)+4)
		count = 0

		Dim it=0 As Long	'table index
		For i = 0 To txlen-1
			if cmdStr[i]<>Asc(" ") and cmdStr[i]<>0 Then
				'register to table
				table[it]=cmdStr+i*sizeof(Word)
				it++

				For i = i To txlen
					if cmdStr[i]=Asc(" ") Then Exitfor
					if text[i]=Asc(ex"\q") then	i+=SkipDQ(cmdStr,txlen,i+1)':Print "!"
				Next i

				'tarminate 1 opt
				cmdStr[i]=0
			endif 
		Next i
		count=it
		it++
		table[it]=0
	EndFunction
	Sub MakeCommandLineA(ByRef cmd AS CommandLine)
		Dim txt as BytePtr
		txt = Wide2Ansi(cmdStr)
		cmd.ParseCommandLine(txt)
		free(txt)
	End Sub
End Class

'ファイルパス用クラス
Class FilePath
protected
	pathStr As StringClass
	pNull As DWord
	separator As Char	' \
Public

	Sub FilePath()
		setPathSeparator("\")
	End Sub

	Sub setPathSeparator(newSeparator As BytePtr)
		separator=newSeparator[0]
	End Sub

	Sub setPathSeparatorChar(newSeparator As Char)
		separator=newSeparator
	End Sub

	'ファイルかフォルダかはわからないけどパスがセットされた
	Sub SetPath(path As BytePtr)
		'ダブルクォーテーションを削除しつつメモリ確保＆格納
		pathStr.set(DelDQ(path))
		pNull=pathStr.length()
	EndSub

	'フォルダを一階層下げるなどの用途がある
	Sub PushFile(filename As BytePtr)
		if pNull<>0 And pathStr.ptr[pNull-1]<>separator Then
			pathStr.addChar(separator)
		End If
		pathStr.cat(filename)
	EndSub

	Sub PushDir(SubDir As BytePtr)
		PushFile(SubDir)
		pathStr.addChar(separator)
	EndSub

	'ディレクトリから出る
	Sub PopDir()
		Dim i As Long
		For i = pathStr.length()-2 To 0 Step -1
			if pathStr.ptr[i]=separator Then	ExitFor
			if pathStr.ptr[i]=Asc(":") Then ExitSub
		Next i
		pathStr.TerminateIndex(i+1)
		'Base[i+1]=0
	EndSub
	
	'拡張子削除
	Sub deleteExtension()
		Dim extPtr As BytePtr
		extPtr=PathFindExtension(pathStr.ptr)

		if extPtr=NULL Then ExitSub

		pNull=(extPtr-pathStr.ptr) As DWord
		pathStr.TerminateIndex(pNull)
	End Sub

	'文字列やファイル名など追加
	Sub cat(text As BytePtr)
		pathStr.cat(text)
	EndSub

	'ファイル存在チェック
	Function isExist() As Long
		isExist=PathFileExists(pathStr.ptr)
	EndFunction

	Function isDir() As Long
		if PathIsDirectory(pathStr.ptr) Then 
			isDir=TRUE
		Else
			isDir=FASLE
		EndIf
	EndFunction

	Function GetPathString() As String
		GetPathString=pathStr.getString()
	EndFunction

	Function genAddedPath(additionalPath As BytePtr) As String
		genAddedPath=sprintfStr("%s%s",pathStr.ptr,additionalPath)
	EndFunction

	Function GetPath() As BytePtr
		GetPath=pathStr.ptr
	EndFunction

	Function GetFileName() As BytePtr
		GetFileName=PathFindFileName(pathStr.ptr)
	EndFunction

	Function GetFileExt() As BytePtr
		GetFileExt=PathFindExtension(pathStr.ptr)
	EndFunction

	Function GetFileDirString() As String
		Dim tmp As FilePath
		tmp.setPathSeparatorChar(separator)
		tmp.SetPath(pathStr.ptr)
		tmp.PopDir()
		GetFileDirString=MakeStr(tmp.GetPath())
	EndFunction

	Sub Destroy()
		pathStr.freeStr()
		pNull=0
	EndSub

	Sub ~FilePath()
		Destroy()
	EndSub

End Class


'EasyIOのクラス版
Class Device 
	Inherits File
	
Public
	Function IoCommand(ioCommand As DWord) As BOOL
		Dim dwAB As DWord
		if DeviceIoControl(hFile,ioCommand,NULL,0,NULL,0,VarPtr(dwAB),NULL)=0 Then _
			ExitFunction
		IoCommand=TRUE
	End Function
End Class

'速度重視の文字列クラス
Const STRCLASS_SPF_BUFFER = 1024
Class StringClass
Private
	bufferSize As DWord
	pNull As DWord	'nullpos
	size As DWord	'buffer size
Public
	ptr As BytePtr	'string

	Function cat(text As BytePtr) As Long
		Dim txlen As DWord
		txlen=lstrlen(text)

		Dim buflen AS DWord
		buflen = (pNull+txlen+1)
		if buflen >= size Then allocStr(buflen)
		memcpy(ptr+pNull,text,txlen)
		pNull+=txlen
		ptr[pNull]=0
	EndFunction

	Sub insertHead(newStr As BytePtr)
		Dim tmp As BytePtr
		copyToNewPtr(tmp)
		set(newStr)
		cat(tmp)
	End Sub

	Sub replaceChar(old As *Byte,newc As *Byte)
		if pNull=0 Then ExitSub
		Dim i As Long
		Do
			if ptr[i]=0 Then ExitSub
			if ptr[i]=old[0] Then ptr[i]=newc[0]
			i++
		Loop
	End Sub

	'
	Sub requestBuffer(len As Long)
		if pNull+len > size Then allocStr(len+size)
	End Sub

	Sub addChar(char As Char)
		requestBuffer(pNull+1)
		ptr[pNull]=char
		pNull++
		ptr[pNull]=0
	End Sub

	Function cpy(text As BytePtr) As Long
		Dim txlen As DWord
		txlen=lstrlen(text)
		
		Dim buflen AS DWord
		buflen = (txlen+1)
		if buflen > size Then allocStr(buflen)
		memcpy(ptr,text,txlen)
		pNull=txlen
		ptr[pNull]=0
	EndFunction

	Function length() As DWord
		length=pNull
	EndFunction

	Function cmp(text As BytePtr) As Long
		cmp=lstrcmp(ptr,text)
	EndFunction
	Function cmpi(text As BytePtr) As Long
		cmp=lstrcmpi(ptr,text)
	EndFunction

	Function sprintf(lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord )
		Dim txlen As DWord
		txlen=1024'lstrlen(lpFormat)
		if txlen+STRCLASS_SPF_BUFFER+pNull > size then allocStr(txlen+STRCLASS_SPF_BUFFER+pNull)
		pNull+=wsprintf(ptr+pNull,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	EndFunction

	Sub set(text As BytePtr)
		freeStr()
		pNull=lstrlen(text)
		allocStr(pNull)
		memcpy(ptr,text,pNull)
	EndSub

	Sub copyToNewPtr(ByRef dest As BytePtr)
		dest=calloc(pNull+2)
		memcpy(dest,ptr,pNull+1)
	endSub

	Sub update()
		pNull=lstrlen(text)
		size=pNull
	EndSub

	Sub TerminateIndex(pos As DWord)
		ptr[pos]=0
		pNull=pos
	EndSub

	'あとはUnicode系とか、文字列検索とか必要になったら実装 

	Sub allocStr(newSize As DWord)
		size=newSize+5
		if ptr=0 Then 
			ptr=calloc(size)
		Else
			ptr=realloc(ptr,size)
		EndIf
	EndSub

	Sub freeStr()
		if ptr<>0 Then free(ptr):ptr=0
		pNull=0
		size=0
	EndSub

	Sub saveMem()
		ptr=realloc(ptr,pNull+1)
		size=pNull+1
	EndSub

	Function getString() As String
		getString=MakeStr(ptr)
	EndFunction

	Sub StringClass()
		ptr=NULL
		pNull=0
	EndSub

	Sub ~StringClass()
		freeStr()
	EndSub

End Class

'自分のEXEファイルがあるディレクトリを扱う
Class BinalyDirectory
Private
	BinalyRoot As BytePtr
	TempString As BytePtr
	p As Word
Public
	Sub BinalyDirectory()
		Dim exePath[MAX_PATH+1] As Byte,i As Long
		GetModuleFileName(NULL,exePath,MAX_PATH)
		For i = lstrlen(exePath) To 0 Step -1
			If exePath[i]=&H5C then ExitFor' \ だったら
		Next i
		i++
		exePath[i]=0'￥以下を潰す
		BinalyRoot=calloc(i+2)
		memcpy(BinalyRoot,exePath,i+1)
		p=(i+1) As Word
	EndSub

	Sub ~BinalyDirectory()
		if BinalyRoot<>0 Then free(BinalyRoot)
		if TempString<>0 Then free(TempString)
	EndSub

	Function GetBinDir() As BytePtr
		GetBinDir=BinalyRoot
	End Function

	Function MakePath(subPath As BytePtr) As BytePtr
		freeTmp()
		TempString=calloc(p+lstrlen(subPath)+1)

		Dim filtered_subPath As BytePtr
		filtered_subPath = DelDQ(subPath)
		wsprintf(TempString,"%s%s",BinalyRoot,filtered_subPath)
		free(filtered_subPath)

		MakePath=TempString
	End Function

	Function GetMadePath() As BytePtr
		GetMadePath=TempString
	EndFunction

	Sub freeTmp()
		if TempString<>0 Then free(TempString):TempString=0
	EndSub
End Class

Const SEED_CRC32 = &HEDB88320


Class HashCrc32
Public
	_seed As DWord
	_table As *DWord

Public
	Sub HashCrc32()
		_seed = SEED_CRC32
		_table = NULL
	End Sub

	Sub SetHashTable(table As DWordPtr)
		_table = table
	End Sub	

	Function MakeTable() As BOOL
		_table = calloc(256 * SizeOf(DWord))

		Dim i As Long, b As Long, crc As DWord
		For i=0 to 255
			crc = i
			For b=0 To 7
				if crc And 1 Then 
					crc = ( crc >> 1 ) xor _seed
				Else
					crc = crc >> 1
				End If
			Next b
			_table[i] = crc
		Next i	
		
		MakeTable = TRUE	
	End Function

	Function GetHash(data As BytePtr,len As DWord) As DWord
		if _table=NULL Then 
			if MakeTable() = FALSE Then
				ExitFunction
			End If
		End If

		Dim crc32 As DWord
		crc32 = &HFFFFFFFF
		While len
			crc32 = (crc32 >> 8) xor _table[(crc32 xor data[0]) And &HFF];
			len--
			data++
		Wend

		crc32 = NOT(crc32)
		GetHash = crc32
	EndFunction
End Class

Class ABMatrix
Public
	x As Long	'列数
	y As Long 	'行数
Private
	pMatrix As *Double
Public
	Sub ABMatrix(iny As Long,inx As Long)(initMatrix As *Double)
		x=inx
		y=iny
		pMatrix=malloc(sizeof(double)*inx*iny)
		if initMatrix<>NULL Then
			memcpy(pMatrix,initMatrix,sizeof(double)*inx*iny)
		Else
			FillMemory(pMatrix,sizeof(double)*inx*iny,0)
		End If
	End Sub

	Sub ~ABMatrix()
		free(pMatrix) 	:	pMatrix=NULL
	End Sub

	Sub PrintMatrix()(caption As BytePtr)
		if caption=NULL Then caption=""
		printf(ex"%sMatrix[%08X,%d,%d] : \n",caption,pMatrix,x,y)
		Dim ix As Long,iy As Long
		For iy=0 To y-1
			For ix= 0 To x-1
				printfd(ex"%5.2f\t",pMatrix[ix+iy*x])
			Next ix
			Print
		Next iy
		Print ex"-------------------------------\n"
	End Sub

	Sub Overwrite(newMatrix As *Double) 	'double配列から入力
		if newMatrix<>NULL Then
			memcpy(pMatrix,newMatrix,sizeof(double)*x*y)
		End If
	End Sub

	Function Get(pos_y As Long,pos_x As Long) As double
		Get=pMatrix[pos_x+pos_y*x]
	End Function

	Sub Set(value As double,pos_y As Long,pos_x As Long)
		pMatrix[pos_x+pos_y*x]=value
	End Sub

	Sub MakeUnitMatrix()	'現在の行列を破棄し単位行列にする
		Dim ix As Long,iy As Long
		For iy=0 To y-1
			For ix= 0 To x-1
				if ix=iy Then
					pMatrix[ix+iy*x]=1
				Else
					pMatrix[ix+iy*x]=0
				End If
			Next ix
		Next iy
	End Sub

	'小行列を取得, excludeした行, 列を除去した行列を返す
	Function GetSubMatrix(excludeX As Long,excludeY As Long) As *ABMatrix
		Dim ret As *ABMatrix 
		ret=new ABMatrix(x-1,y-1)

		Dim ix As Long,iy As Long,nx As Long,ny As Long
		For iy=0 To y-1
			if iy=excludeY Then Continue
			For ix= 0 To x-1
				if ix=excludeX Then Continue
				ret->Set(pMatrix[ix+iy*x],ny,nx)
				nx++
			Next ix
			nx=0
			ny++
		Next iy
		GetSubMatrix=ret
	End Function

	'行列式detを求める
	Function determinant() As double
		if x=<1 and y=<1 Then	determinant=pMatrix[0]:ExitFunction
		if x<>y Then ExitFunction
		Dim i As Long,ret As double
		Dim work As *ABMatrix
		For i=0 To x-1
			work=GetSubMatrix(i,0)
			if i Mod 2 = 0 Then
				ret += pMatrix[i] * work->determinant()
			Else
				ret -= pMatrix[i] * work->determinant()
			End If
			delete work
		Next i
		determinant=ret
	End Function

	'行列式による逆行列取得（PDF参照）
	Function GetInverseMatrix() As *ABMatrix
		Dim ix As Long, iy As Long, sign As double
		Dim retMx As *ABMatrix, subMx As *ABMatrix, detM As double
		if x=<1 and y=<1 Then	GetInverseMatrix=NULL:ExitFunction

		retMx = new ABMatrix(x,y)	'戻り値の行列
		detM=determinant()
		
		For iy=0 To y-1
			For ix= 0 To x-1
				subMx=GetSubMatrix(iy,ix)	'小行列取得
				if ix Mod 2=iy Mod 2 Then	'＋−で縞々に　偶数&偶数 or 奇数＆奇数
					sign=1
				Else
					sign=-1
				End if
				retMx->Set(sign*subMx->determinant()/detM,iy,ix)	'符号 * det(小行列) / detM
				delete subMx
			Next ix
		Next iy
		GetInverseMatrix=retMx
	End Function

	'LU分解したものを取得(PDF準拠)
	Sub GetLU(ByRef LMatrix As *ABMatrix,ByRef UMatrix As *ABMatrix)
		Dim retL As *ABMatrix,retU As *ABMatrix
		Dim ix As Long,iy As Long,w As Long, sigma As double

		retL=new ABMatrix(x,y)
		retU=new ABMatrix(x,y)

		For iy=0 To y-1
			For ix= 0 To x-1
				'L
				if ix=<iy Then
					if ix=0 Then 
						retL->Set(pMatrix[iy*x],iy,0)
					Elseif ix=iy Then
						'シグマの計算
						sigma=0
						For w=0 To ix-1
							sigma+=retL->Get(iy,w) * retU->Get(w,ix)
						Next w								
						retL->Set(pMatrix[ix+iy*x]-sigma,iy,ix)
					Else
						'斜め(ix=iy以外)、先頭列(ix=0)以外の時つまりL(i,k)
						sigma=0
						For w=0 To ix-1
							sigma+=retL->Get(iy,w) * retU->Get(w,ix)
						Next w
						retL->Set(pMatrix[ix+iy*x] - sigma,iy,ix)
					End If
				End If

				'U
				if ix=>iy Then
					if ix=iy Then 
						retU->Set(1,ix,iy)	'u(i,i)=1
					Elseif iy=0 Then
						retU->Set(pMatrix[ix]/pMatrix[0],0,ix)
					Else
						'斜め以外で1行目以外の時
						sigma=0
						For w=0 To ix-1
							sigma+=retL->Get(iy,w) * retU->Get(w,ix)
						Next w
						retU->Set((pMatrix[ix+iy*x]-sigma)/retL->Get(iy,iy),iy,ix)
					End If
				End If				
			Next ix
		Next iy

		if VarPtr(LMatrix)<>NULL Then
			LMatrix=retL
		Else
			delete LMatrix
		End If
		if VarPtr(UMatrix)<>NULL Then
			UMatrix=retU
		Else
			delete UMatrix
		End If
	End Sub

	'ガウス消去法による逆行列取得
	Function GaussInverse() As *ABMatrix
		Dim ret As *ABMatrix,tmp As *ABMatrix
		Dim ix As Long,iy As Long,sx As Long
		Dim coff As double

		ret=new ABMatrix(y,x)	'右側の行列　最初は単位行列
		ret->MakeUnitMatrix()
		tmp=new ABMatrix(y,x)	'左側のコピー
		tmp->Overwrite(pMatrix)

		For ix=0 To x-1
			'ターゲットを割り算で１にする
			coff=tmp->Get(ix,ix)
			if coff<>1 then
				For sx = 0 To x-1
					tmp->Set(tmp->Get(ix,sx)/coff,ix,sx)
					ret->Set(ret->Get(ix,sx)/coff,ix,sx)
				Next sx
			End If

			'ターゲット行以外のターゲット列を0にする
			For iy=0 To y-1
				if iy<>ix Then
					coff=tmp->Get(iy,ix)
					For sx = 0 To x-1
						'更新セル = 更新セル	- 消したいとこ　 × 今の列の1にしたいとこ（ix=iy） 
						tmp->Set(tmp->Get(iy,sx) - tmp->Get(ix,sx) * coff ,iy,sx)
						ret->Set(ret->Get(iy,sx) - ret->Get(ix,sx) * coff ,iy,sx)
					Next sx
				End If
			Next iy
		Next ix

		GaussInverse=ret
		delete tmp
	End Function
End Class

Class Mutex
	cs As CRITICAL_SECTION	'バッファー保護用クリティカルセクション	
Public
	Sub Mutex()
		InitializeCriticalSection(cs)
	End Sub
	
	Sub ~Mutex()
		DeleteCriticalSection(cs)
	End Sub
	
	Sub Lock()		
		EnterCriticalSection(cs)
	End Sub
	
	Sub Unlock()		
		LeaveCriticalSection(cs)
	End Sub
End Class

Class AutoLock
	p_mutex AS *Mutex
Public
	Sub AutoLock(ByRef mutex As Mutex)
		p_mutex = VarPtr(mutex)
		p_mutex->Lock()
	End Sub

	Sub AutoLock(mutex As *Mutex)
		p_mutex = mutex
		p_mutex->Lock()
	End Sub

	Sub ~AutoLock()
		p_mutex->Unlock()
	End Sub
End Class

Class WindowsEventAPI
	handle AS HANDLE
Public
	Function Init(id AS BytePtr) As BOOL
		handle=CreateEvent(NULL, TRUE, FALSE, id)
		if handle then Init = TRUE
	End Function

	Sub Deinit()
		CloseHandle(handle)
		handle = NULL
	End Sub

	Sub Set()
		SetEvent(handle)
	End Sub

	Sub Reset()
		ResetEvent(handle)
	End Sub

	Function Wait(timeout AS DWord) As BOOL
		Dim ret AS DWord
		ret = WaitForSingleObject(handle, timeout)
		if ret = WAIT_OBJECT_0 then Wait=TRUE
	End Function

	Sub ~WindowsEventAPI()
		if handle then Deinit()
	End Sub
End Class


Class BufferClass
Private
	bufferSize As DWord
	pNull As DWord	'nullpos
	size As DWord	'buffer size
Public
	ptr As BytePtr	'string
	Function cat(input As BytePtr, inputSize As DWord) As Long
		if pNull+inputSize >= size Then alloc(inputSize+size)
		memcpy(ptr+pNull,input,inputSize)
		pNull+=inputSize
	EndFunction
	Sub setLength(new_size As DWord)
		if new_size>size then
			printf(ex"####### ASSERT: BufferClass::setLength err %d\n",new_size)
			debug
		endif
		pNull = new_size
	End Sub
/*
	Sub insertHead(newStr As BytePtr)
		Dim tmp As BytePtr
		copyToNewPtr(tmp)
		set(newStr)
		cat(tmp)
	End Sub

	Sub replaceChar(old As *Byte,newc As *Byte)
		if pNull=0 Then ExitSub
		Dim i As Long
		Do
			if ptr[i]=0 Then ExitSub
			if ptr[i]=old[0] Then ptr[i]=newc[0]
			i++
		Loop
	End Sub

	'
	Sub requestBuffer(len As Long)
		if pNull+len > size Then allocStr(len+size)
	End Sub

	Sub addChar(char As Char)
		requestBuffer(pNull+1)
		ptr[pNull]=char
		pNull++
		ptr[pNull]=0
	End Sub

	Function cpy(text As BytePtr) As Long
		Dim txlen As DWord
		txlen=lstrlen(text)
		if txlen > size Then allocStr(txlen)
		memcpy(ptr,text,txlen)
		pNull=txlen
		ptr[pNull]=0
	EndFunction*/

	Function length() As DWord
		length=pNull
	EndFunction
/*
	Function cmp(text As BytePtr) As Long
		cmp=lstrcmp(ptr,text)
	EndFunction
	Function cmpi(text As BytePtr) As Long
		cmp=lstrcmpi(ptr,text)
	EndFunction

	Function sprintf(lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord )
		Dim txlen As DWord
		txlen=1024'lstrlen(lpFormat)
		if txlen+STRCLASS_SPF_BUFFER+pNull > size then allocStr(txlen+STRCLASS_SPF_BUFFER+pNull)
		pNull+=wsprintf(ptr+pNull,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
	EndFunction

	Sub set(text As BytePtr)
		freeStr()
		pNull=lstrlen(text)
		allocStr(pNull)
		memcpy(ptr,text,pNull)
	EndSub

	Sub copyToNewPtr(ByRef dest As BytePtr)
		dest=calloc(pNull+2)
		memcpy(dest,ptr,pNull+1)
	endSub

	Sub update()
		pNull=lstrlen(text)
		size=pNull
	EndSub

	Sub TerminateIndex(pos As DWord)
		ptr[pos]=0
		pNull=pos
	EndSub

	'あとはUnicode系とか、文字列検索とか必要になったら実装 
*/
	Sub alloc(newSize As DWord)
		size=newSize+5
		if ptr=0 Then 
			ptr=calloc(size)
		Else
			ptr=realloc(ptr,size)
		EndIf
	EndSub

	Sub _free()
		if ptr<>0 Then free(ptr):ptr=0
		pNull=0
		size=0
	EndSub

	Sub truncate()
		ptr=realloc(ptr,pNull+1)
		size=pNull+1
	EndSub

	Sub BufferClass()
		ptr=NULL
		pNull=0
	EndSub

	Sub ~BufferClass()
		_free()
	EndSub
End Class



Function LoadFileToMemory(filename AS BytePtr, buf AS *BufferClass) AS BOOL
	Dim in As File
	if in.openFile(filename, GENERIC_READ) = FALSE then ExitFunction

	buf->alloc(in.length())
	buf->setLength(in.length())

	Dim ret AS Long
	ret =  in.read(buf->ptr, in.length())
	if ret <= 0 then
		printf(ex"### LoadFile fail. expect=%d, real=%d\n", in.length(), ret)
		in.close()
		buf->_free()
		ExitFunction
	End If

	in.close()
	LoadFileToMemory=TRUE
End Function
'------------------------------------------------------
'			たぶんもう使わない関数
'------------------------------------------------------
'#include <EasyIO.sbp>


'引数をNULLで区切る。NULL NULLで終わり (例）コマンド\0引数１\0"引数2"\0\0
Function MakeCmdLine(Text As BytePtr) As BytePtr
	Dim i As DWORD,fDQ As Byte,SP=-1 As Long'-1でセット待ち
	dim dbg As Byte
	dim  Buf As BytePtr,bi As DWORD
	Const SPR=&H00'区切り文字NULL

	If Text=0 then ExitFunction
	Buf=calloc(lstrlen(Text)+4)
	
	For i = 0 To lstrlen(Text)
		If SP=-1 then
			If Text[i]<>&H20 then
				SP=i
				dbg=1
			Else
				Continue
			EndIf
		EndIf

		If fDQ=0 then
			If Text[i]=&H20 then
				memcpy(Buf+bi,Text+SP,i-SP)
				bi+=(i-SP)+1
				Buf[bi-1]=SPR
				SP=-1
			ElseIf Text[i]=0 then
				memcpy(Buf+bi,Text+SP,i-SP)
				bi+=(i-SP)+1
				Buf[bi-1]=SPR
			elseIf Text[i]=&H22 then'Doubleクォーテート
				fDQ=Not(fDQ)
			Else
			EndIf
			dbg=0
		Else
			If Text[i]=&H22 then'Doubleクォーテート
				fDQ=Not(fDQ)
			Else
			EndIf
		EndIf
	Next i
	Buf[bi]=0
	Buf[bi+1]=0
	MakeCmdLine=Buf
EndFunction

'↑で作られた文字列を扱う関数
'↑はNULLで区切られているので、lstrcpyみたいな関数が使える。
'この関数は指定した番号の引数をとってくる。
'EX) Text=cmd1\0cmd2\0opt1\0"path"\0\0
'2を指定すれば3つ目の「opt1」の開始アドレス0xAが返ってくる。MakeStr(Text+0xA)で「opt1」という文字列を取り出せる。
Function GetCmdAdr(Text As BytePtr,Num As Byte) As DWORD
	Dim i As DWORD,C As Byte
	If Num=0 then GetCmdAdr=0:ExitFunction
	Do
		If Text[i]=0 then
			If Text[i+1]=0 then GetCmdAdr=-1:ExitDo'ダブルNULL＝END
			C++
			If C=Num then GetCmdAdr=i+1:ExitDo
		EndIf
		i++
	Loop
EndFunction

Function FillString(Text As BytePtr,Buf As BytePtr,Num As DWord ,Max As DWord) As DWord
	Dim i As DWord/*,tSize As DWord*/,ti As DWord,nMake As DWord
'	tSize=lstrlen(Text)
	Do
		If i=>Max-1 OR nMake>=Num  then ExitDo
		Buf[i]=Text[ti]
		i++
		ti++
		If Text[ti]=0 then ti=0:nMake++
	Loop
	Buf[i]=0
	Buf[Max-1]=0
	FillString=i
EndFunction

'NULL文字記憶型strcat
Sub pstrcat(To As BytePtr,Src As BytePtr ,ByRef Ptr As DWORD)(Size As DWORD)
	If Size = 0 then Size=lstrlen(Src)
	memcpy(To+Ptr,Src,Size)
	'(free(Src)
	Ptr += Size
endsub

Function Lit2Big(Data As Word) As Dword
	Dim big[4] As Byte,In[3] As Byte
	memcpy(In,VarPtr(Data),2)
/*	big[0]=In[3]
	big[1]=In[2]
	big[2]=In[1]
	big[3]=In[0]*/
	big[0]=In[1]
	big[1]=In[0]
	memcpy(VarPtr(Lit2Big),big,2)
EndFunction
